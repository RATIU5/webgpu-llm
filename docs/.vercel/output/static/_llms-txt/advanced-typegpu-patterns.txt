<SYSTEM>Advanced TypeGPU Patterns: Externals, resolve API, WebGPU interoperability, and React Native support</SYSTEM>

# Advanced TypeGPU Patterns

## Overview [Section titled “Overview”](#overview) TypeGPU provides advanced features for building production-ready GPU applications: externals for dependency management, the Resolve API for debugging, external textures for video processing, WebGPU interoperability, and React Native support. ## Externals and $uses [Section titled “Externals and $uses”](#externals-and-uses) ### Automatic Dependency Management [Section titled “Automatic Dependency Management”](#automatic-dependency-management) Externals allow TGSL functions to reference resources and other functions without manual binding management: Externals in template literals ```typescript const timeUniform = root.createBuffer(d.f32).$usage("uniform"); const particleBuffer = root.createBuffer(d.arrayOf(d.vec3f, 1000)).$usage("storage"); const updateParticles = tgpu.fn([d.u32], d.void).does`(idx: u32) { let dt = ${timeUniform}; particles[idx] = particles[idx] + velocities[idx] * dt; }`.$uses({ particles: particleBuffer, velocities: velocityBuffer, }); ``` ### Nested Dependencies [Section titled “Nested Dependencies”](#nested-dependencies) TypeGPU walks the dependency tree automatically: Dependency chain ```typescript const computeGravity = tgpu.fn([d.vec3f, d.vec3f], d.vec3f) .does`(pos1: vec3f, pos2: vec3f) -> vec3f { let diff = pos2 - pos1; return normalize(diff) * ${d.f32(9.81)} / dot(diff, diff); }`; const physicsUpdate = tgpu.fn([d.u32], d.void).does`(idx: u32) { totalForce += ${computeGravity}(positions[idx], otherPos); }`.$uses({ positions: positionBuffer }); // computeGravity is automatically included ``` ## Resolve API [Section titled “Resolve API”](#resolve-api) ### Debugging Generated WGSL [Section titled “Debugging Generated WGSL”](#debugging-generated-wgsl) Use `tgpu.resolve()` to inspect generated shader code: Inspect WGSL output ```typescript const wgsl = tgpu.resolve(myShaderFunction); console.log(wgsl); // With context for bind group information const resolved = tgpu.resolveWithContext({ main: shaderFunction, uniforms: uniformBuffer, }); console.log("WGSL:", resolved.code); console.log("Bind Groups:", resolved.bindGroupLayouts); ``` ## External Textures [Section titled “External Textures”](#external-textures) ### Video Frame Processing [Section titled “Video Frame Processing”](#video-frame-processing) External textures enable zero-copy GPU access to video frames: Process video frames ```typescript const video = document.createElement("video"); video.src = "video.mp4"; video.play(); function frame() { const externalTexture = device.importExternalTexture({ source: video }); // Use in shader (must complete in same frame) processFrame(externalTexture); requestAnimationFrame(frame); } ``` Frame Lifetime External textures are destroyed automatically when JavaScript returns to the browser. Create and consume in the same callback. ### Camera Input [Section titled “Camera Input”](#camera-input) Access camera stream ```typescript const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1920, height: 1080 }, }); const video = document.createElement("video"); video.srcObject = stream; video.play(); // Use same pattern as video files ``` ## WebGPU Interoperability [Section titled “WebGPU Interoperability”](#webgpu-interoperability) ### Access Raw Resources [Section titled “Access Raw Resources”](#access-raw-resources) Unwrap TypeGPU to WebGPU ```typescript const root = await tgpu.init(); // Get raw GPUDevice const device = root.unwrap().device; // Get raw GPUBuffer from typed buffer const typedBuffer = root.createBuffer(schema, data).$usage("storage"); const rawBuffer = root.unwrap(typedBuffer); // Use in vanilla WebGPU const bindGroup = device.createBindGroup({ layout: bindGroupLayout, entries: [{ binding: 0, resource: { buffer: rawBuffer } }], }); ``` ### Gradual Migration [Section titled “Gradual Migration”](#gradual-migration) TypeGPU is non-contagious—use it incrementally: Mix TypeGPU with vanilla WebGPU ```typescript // TypeGPU for type-safe buffer management const typedBuffer = root.createBuffer(schema, data).$usage("storage"); // Vanilla WebGPU for custom pipeline const rawBuffer = root.unwrap(typedBuffer); const vanillaPipeline = device.createComputePipeline({ ... }); // TypeGPU for type-safe writes await typedBuffer.write(newData); ``` ## React Native Support [Section titled “React Native Support”](#react-native-support) ### Setup [Section titled “Setup”](#setup) ```bash npm install react-native-wgpu typegpu npm install --save-dev @webgpu/types unplugin-typegpu ``` Configure Babel: babel.config.js ```javascript module.exports = (api) => { api.cache(true); return { presets: ["babel-preset-expo"], plugins: ["unplugin-typegpu/babel"], }; }; ``` ### Mobile Rendering [Section titled “Mobile Rendering”](#mobile-rendering) React Native canvas ```typescript import { Canvas, useCanvasEffect } from 'react-native-wgpu'; export default function App() { const ref = useCanvasEffect(async () => { const context = ref.current!.getContext('webgpu')!; const device = await navigator.gpu.requestAdapter() .then(a => a!.requestDevice()); context.configure({ device, format: navigator.gpu.getPreferredCanvasFormat() }); const frame = () => { // ... render commands ... device.queue.submit([commandEncoder.finish()]); context.present(); // Required on React Native! requestAnimationFrame(frame); }; requestAnimationFrame(frame); }); return <Canvas ref={ref} style={{ flex: 1 }} />; } ``` Mobile Differences * Requires `context.present()` after submit * iOS: Disable Metal validation in Xcode * Expo: Must use `expo prebuild`, not Expo Go ## Generator CLI (tgpu-gen) [Section titled “Generator CLI (tgpu-gen)”](#generator-cli-tgpu-gen) Convert WGSL to TypeGPU: ```bash # Single file npx tgpu-gen src/shaders/compute.wgsl # Glob pattern npx tgpu-gen "src/shaders/**/*.wgsl" # Watch mode npx tgpu-gen "src/shaders/**/*.wgsl" --watch ``` ## CPU Simulation [Section titled “CPU Simulation”](#cpu-simulation) Test shaders on CPU without GPU: Unit test GPU functions ```typescript import { test, expect } from "vitest"; const normalize2D = (x: number, y: number) => { "use gpu"; const length = Math.sqrt(x * x + y * y); return { x: x / length, y: y / length }; }; test("normalize2D produces unit vectors", () => { const result = tgpu["~unstable"].simulate(normalize2D, [3, 4]); expect(result.x).toBeCloseTo(0.6); expect(result.y).toBeCloseTo(0.8); }); ``` Limitations * No buffer/texture access * CPU/GPU floating-point may differ slightly * For correctness testing, not performance ## Custom Extensions [Section titled “Custom Extensions”](#custom-extensions) ### Building Domain Libraries [Section titled “Building Domain Libraries”](#building-domain-libraries) Particle system library ```typescript import tgpu from "typegpu"; import * as d from "typegpu/data"; export const ParticleSchema = d.struct({ position: d.vec3f, velocity: d.vec3f, lifetime: d.f32, }); export class ParticleSystem { private particleBuffer: TgpuBuffer; constructor(root: TgpuRoot, maxParticles: number) { this.particleBuffer = root .createBuffer(d.arrayOf(ParticleSchema, maxParticles)) .$usage("storage"); } getBuffer() { return this.particleBuffer; } } ``` ### Custom Data Types [Section titled “Custom Data Types”](#custom-data-types) Physics type library ```typescript import * as d from "typegpu/data"; export const Quaternion = d.vec4f; export const RigidBody = d.struct({ position: d.vec3f, rotation: Quaternion, linearVelocity: d.vec3f, angularVelocity: d.vec3f, mass: d.f32, }); ``` ## Advanced Slots [Section titled “Advanced Slots”](#advanced-slots) ### Slot Hierarchies [Section titled “Slot Hierarchies”](#slot-hierarchies) Nested configuration ```typescript const simulationConfig = tgpu.slot({ physics: tgpu.slot({ gravity: d.f32, damping: d.f32, }), rendering: tgpu.slot({ particleSize: d.f32, }), }); const pipeline = root .makeComputePipeline(shader) .$with(simulationConfig, { physics: { gravity: -9.81, damping: 0.99 }, rendering: { particleSize: 5.0 }, }); ``` ### Runtime Configuration [Section titled “Runtime Configuration”](#runtime-configuration) Debug visualization modes ```typescript const shaderMode = tgpu.slot(d.u32); const shader = tgpu.fn([d.u32], d.vec4f).does`(idx: u32) -> vec4f { switch (${shaderMode}) { case 0u: { return normalVisualization(idx); } case 1u: { return depthVisualization(idx); } default: { return fullRendering(idx); } } }`; // Switch at runtime pipeline.$with(shaderMode, 1); ``` ## Common Pitfalls [Section titled “Common Pitfalls”](#common-pitfalls) Unwrapped Resources Lose Type Safety ```typescript const rawBuffer = root.unwrap(typedBuffer); await rawBuffer.write([1, 2, 3]); // TypeError! // Use typed buffer for write operations await typedBuffer.write([1, 2, 3]); // Correct ``` External Texture Lifetime ```typescript // Wrong: texture destroyed before use const tex = device.importExternalTexture({ source: video }); requestAnimationFrame(() => renderWithTexture(tex)); // Error! // Correct: create and use in same frame requestAnimationFrame(() => { const tex = device.importExternalTexture({ source: video }); renderWithTexture(tex); }); ``` Editing Generated Files Never edit files generated by tgpu-gen. Import and extend instead: ```typescript // compute.ts (generated - don't edit!) export const updateParticles = /* ... */; // particle-system.ts (your code) import { updateParticles } from './compute'; export class ParticleSystem { /* custom logic */ } ``` ## Framework Integration [Section titled “Framework Integration”](#framework-integration) ### Three.js with TypeGPU [Section titled “Three.js with TypeGPU”](#threejs-with-typegpu) Use TypeGPU for type-safe compute shaders alongside Three.js rendering: Three.js + TypeGPU compute ```typescript import * as THREE from "three/webgpu"; import tgpu from "typegpu"; import * as d from "typegpu/data"; // Share device between Three.js and TypeGPU const renderer = new THREE.WebGPURenderer(); await renderer.init(); const root = await tgpu.init({ device: renderer.backend.device, // Reuse Three.js device }); // TypeGPU compute for physics const positions = root.createBuffer(d.arrayOf(d.vec3f, 1000)).$usage("storage"); // Three.js reads TypeGPU buffer const geometry = new THREE.BufferGeometry(); geometry.setAttribute("position", new THREE.BufferAttribute( root.unwrap(positions), 3 )); function animate() { // TypeGPU: Update physics physicsComputePipeline.dispatchWorkgroups(64); // Three.js: Render scene renderer.render(scene, camera); requestAnimationFrame(animate); } ``` ### Babylon.js with TypeGPU [Section titled “Babylon.js with TypeGPU”](#babylonjs-with-typegpu) Babylon.js + TypeGPU ```typescript import { Engine, Scene } from "@babylonjs/core"; import tgpu from "typegpu"; // Initialize Babylon with WebGPU const engine = new Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, }); await engine.initAsync(); // Initialize TypeGPU with Babylon's device const root = await tgpu.init({ device: engine._device, // Access internal device }); // Use TypeGPU for compute workloads const computeBuffer = root .createBuffer(d.arrayOf(d.f32, 1024)) .$usage("storage"); // Babylon handles rendering, TypeGPU handles compute engine.runRenderLoop(() => { computePipeline.execute(); // TypeGPU compute scene.render(); // Babylon render }); ``` ### Pattern: Hybrid Rendering [Section titled “Pattern: Hybrid Rendering”](#pattern-hybrid-rendering) Framework renders, TypeGPU computes ```typescript // 1. TypeGPU owns compute resources const particleData = root.createBuffer(particleSchema, particles); const computePipeline = root .withCompute(updateParticlesShader) .createPipeline(); // 2. Framework reads results const rawBuffer = root.unwrap(particleData); framework.setInstanceBuffer(rawBuffer); // 3. Render loop function frame() { computePipeline.execute(); // TypeGPU: physics framework.render(scene, camera); // Framework: graphics requestAnimationFrame(frame); } ``` WebGPU Renderer Required Framework integration requires WebGPU backends: * Three.js: `import * as THREE from "three/webgpu"` * Babylon.js: Enable WebGPU engine mode WebGL renderers cannot share resources with TypeGPU. ## Resources [Section titled “Resources”](#resources)