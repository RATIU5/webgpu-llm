<SYSTEM>WGSL Address Spaces: Understanding function, private, workgroup, uniform, and storage address spaces</SYSTEM>

# WGSL Address Spaces

## Overview [Section titled “Overview”](#overview) WGSL defines five address spaces representing distinct memory regions with different performance, visibility, and access characteristics. Each address space maps to specific hardware memory types and determines how GPU cores read and write data. ## function Address Space [Section titled “function Address Space”](#function-address-space) The `function` address space stores local variables that exist only during function execution, analogous to stack memory in CPU programming. Function-local variables ```wgsl fn compute_normal(pos: vec3f) -> vec3f { var temp_vec: vec3f = pos; // Implicitly function address space var result: vec3f; temp_vec = normalize(temp_vec); result = temp_vec * 2.0 - 1.0; return result; } ``` | Characteristic | Description | | -------------- | ----------------------------------------- | | Lifetime | Allocated on entry, deallocated on return | | Visibility | Private to invocation | | Speed | Fastest (registers or L1 cache) | | Size limit | 8KB per function | Caution Large arrays in function space may spill to slower global memory. Keep function-local arrays small; use storage buffers for large datasets. ## private Address Space [Section titled “private Address Space”](#private-address-space) The `private` address space stores module-scope variables that persist for the entire shader execution, with each invocation getting its own copy. Private module-scope variables ```wgsl var<private> invocation_counter: u32 = 0u; var<private> accumulated_color: vec4f; @fragment fn main(@location(0) uv: vec2f) -> @location(0) vec4f { invocation_counter += 1u; accumulated_color += texture_sample(uv); return accumulated_color; } ``` | Characteristic | Description | | -------------- | -------------------------- | | Scope | Module (outside functions) | | Visibility | Per-invocation isolation | | Mutability | Read and write | | Size limit | 8KB per shader | Use `private` for accumulators, caching expensive computations, and state that persists within a single invocation. ## workgroup Address Space [Section titled “workgroup Address Space”](#workgroup-address-space) The `workgroup` address space provides shared memory visible to all invocations within a compute shader workgroup. This is critical for parallel algorithms requiring thread cooperation. Shared workgroup memory ```wgsl var<workgroup> shared_data: array<f32, 256>; var<workgroup> group_sum: atomic<u32>; @compute @workgroup_size(256) fn main(@builtin(local_invocation_index) local_idx: u32) { // Each thread loads one element shared_data[local_idx] = input_buffer[local_idx]; // Barrier ensures all loads complete before any thread proceeds workgroupBarrier(); // Now all threads can safely read any element let neighbor = shared_data[(local_idx + 1u) % 256u]; } ``` | Characteristic | Description | | -------------- | --------------------------------------- | | Availability | Compute shaders only | | Scope | Visible to all invocations in workgroup | | Speed | Fast (on-chip shared memory) | | Size limit | \~16KB typically | Synchronization Required Missing or misplaced barriers cause race conditions. Always use `workgroupBarrier()` before reading data written by other threads. ### Synchronization Pattern [Section titled “Synchronization Pattern”](#synchronization-pattern) Three-phase synchronization ```wgsl var<workgroup> tile: array<f32, 256>; @compute @workgroup_size(16, 16) fn main(@builtin(local_invocation_id) local_id: vec3u) { let idx = local_id.x + local_id.y * 16u; // Phase 1: All threads load tile[idx] = compute_value(local_id); workgroupBarrier(); // Phase 2: All threads process let sum = tile[idx] + tile[(idx + 1u) % 256u]; workgroupBarrier(); // Phase 3: Write results output[idx] = sum; } ``` ### Atomics in Workgroup Memory [Section titled “Atomics in Workgroup Memory”](#atomics-in-workgroup-memory) Workgroup atomic counter ```wgsl var<workgroup> counter: atomic<u32>; @compute @workgroup_size(64) fn count_positives( @builtin(local_invocation_index) local_idx: u32, @builtin(workgroup_id) wg_id: vec3u ) { if (local_idx == 0u) { atomicStore(&counter, 0u); } workgroupBarrier(); let global_idx = wg_id.x * 64u + local_idx; if (data[global_idx] > 0.0) { atomicAdd(&counter, 1u); } workgroupBarrier(); if (local_idx == 0u) { result[wg_id.x] = atomicLoad(&counter); } } ``` ## uniform Address Space [Section titled “uniform Address Space”](#uniform-address-space) The `uniform` address space stores read-only data shared across all invocations. The GPU broadcasts uniform data efficiently, making it ideal for transformation matrices and material properties. Uniform buffer usage ```wgsl struct CameraUniforms { view_matrix: mat4x4f, projection_matrix: mat4x4f, camera_position: vec3f, near_plane: f32, far_plane: f32, } @group(0) @binding(0) var<uniform> camera: CameraUniforms; @vertex fn vertex_main(@location(0) position: vec3f) -> @builtin(position) vec4f { let world_pos = vec4f(position, 1.0); let view_pos = camera.view_matrix * world_pos; return camera.projection_matrix * view_pos; } ``` | Characteristic | Description | | -------------- | ----------------------------- | | Access | Read-only | | Visibility | All invocations see same data | | Optimization | GPU broadcasts efficiently | | Size limit | 16-64KB per binding | ### Uniform vs Storage [Section titled “Uniform vs Storage”](#uniform-vs-storage) | Aspect | `uniform` | `storage` | | -------------- | ---------------------- | ----------------------------- | | Access | Read-only | Read-only or read-write | | Size limit | \~64KB | GB+ | | Use case | Per-draw constants | Large datasets | | Access pattern | Same value all threads | Different elements per thread | ## storage Address Space [Section titled “storage Address Space”](#storage-address-space) The `storage` address space provides access to large buffers with optional write capability. Storage buffers can hold gigabytes of data and support per-element random access. Storage buffer read/write ```wgsl struct Particle { position: vec3f, velocity: vec3f, lifetime: f32, } @group(0) @binding(0) var<storage, read> particles_in: array<Particle>; @group(0) @binding(1) var<storage, read_write> particles_out: array<Particle>; @compute @workgroup_size(64) fn update_particles(@builtin(global_invocation_id) global_id: vec3u) { let idx = global_id.x; var p = particles_in[idx]; p.position += p.velocity * delta_time; p.lifetime -= delta_time; particles_out[idx] = p; } ``` ### Access Modes [Section titled “Access Modes”](#access-modes) | Mode | Description | | ------------ | --------------------------------------- | | `read` | Read-only access, enables optimizations | | `read_write` | Full read and write access | ### Runtime-Sized Arrays [Section titled “Runtime-Sized Arrays”](#runtime-sized-arrays) Storage buffers support runtime-sized arrays as the last struct member: Runtime-sized array ```wgsl struct ParticleBuffer { count: u32, _padding: u32, _padding2: u32, _padding3: u32, particles: array<Particle> // Size determined at runtime } @group(0) @binding(0) var<storage, read> data: ParticleBuffer; @compute @workgroup_size(64) fn process(@builtin(global_invocation_id) id: vec3u) { if (id.x >= data.count) { return; } let p = data.particles[id.x]; } ``` ### Atomics in Storage [Section titled “Atomics in Storage”](#atomics-in-storage) Global atomic counter ```wgsl @group(0) @binding(0) var<storage, read_write> global_counter: atomic<u32>; @compute @workgroup_size(64) fn count(@builtin(global_invocation_id) id: vec3u) { if (condition) { atomicAdd(&global_counter, 1u); } } ``` ## Address Space Comparison [Section titled “Address Space Comparison”](#address-space-comparison) | Address Space | Scope | Visibility | Access | Speed | Size | | ------------- | --------- | ---------- | ----------- | --------- | ------- | | `function` | Function | Invocation | R/W | Fastest | 8KB | | `private` | Module | Invocation | R/W | Very Fast | 8KB | | `workgroup` | Workgroup | Workgroup | R/W | Fast | 16KB | | `uniform` | Buffer | All | Read | Fast | 16-64KB | | `storage` | Buffer | All | Read or R/W | Variable | Large | ## Memory Access Patterns [Section titled “Memory Access Patterns”](#memory-access-patterns) ### Using Workgroup Memory for Irregular Access [Section titled “Using Workgroup Memory for Irregular Access”](#using-workgroup-memory-for-irregular-access) Blur kernel with workgroup cache ```wgsl var<workgroup> tile: array<f32, 256>; @compute @workgroup_size(16, 16) fn blur_kernel( @builtin(global_invocation_id) global_id: vec3u, @builtin(local_invocation_id) local_id: vec3u ) { // Coalesced load into shared memory let local_idx = local_id.x + local_id.y * 16u; tile[local_idx] = input[global_id.x + global_id.y * width]; workgroupBarrier(); // Random access within fast workgroup memory var sum: f32 = 0.0; for (var dy = -1; dy <= 1; dy++) { for (var dx = -1; dx <= 1; dx++) { let neighbor_idx = (local_id.x + dx) + (local_id.y + dy) * 16u; sum += tile[neighbor_idx]; } } output[global_id.x + global_id.y * width] = sum / 9.0; } ``` ## Choosing an Address Space [Section titled “Choosing an Address Space”](#choosing-an-address-space) ### Optimization Tips [Section titled “Optimization Tips”](#optimization-tips) Cache storage reads ```wgsl // ✗ Suboptimal: multiple reads let result = data[id.x] * 2.0 + data[id.x] * 3.0; // ✓ Better: cache in local variable let value = data[id.x]; let result = value * 2.0 + value * 3.0; ``` Use workgroup memory for reuse ```wgsl var<workgroup> cached: array<f32, 256>; cached[local_idx] = input_buffer[global_idx]; workgroupBarrier(); let value = cached[some_index]; // Fast access ``` ## TypeGPU Address Space Mapping [Section titled “TypeGPU Address Space Mapping”](#typegpu-address-space-mapping) TypeGPU abstracts address spaces through buffer usage declarations: TypeGPU buffer usage ```typescript import tgpu from "typegpu"; import { arrayOf, f32, struct, vec3f } from "typegpu/data"; // Uniform buffer (uniform address space) const CameraSchema = struct({ viewMatrix: mat4x4f, projMatrix: mat4x4f, }); const camera = root.createBuffer(CameraSchema, data).$usage("uniform"); // Storage buffer read-only (storage, read) const particles = root.createBuffer(arrayOf(ParticleSchema, 1000)).$usage("storage"); // Storage buffer read-write (storage, read_write) const output = root.createBuffer(arrayOf(f32, 1000)).$usage("storage"); ``` TypeGPU infers the appropriate WGSL address space from the usage pattern.