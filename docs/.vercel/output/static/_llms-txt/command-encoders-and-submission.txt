<SYSTEM>Command Encoders and Submission: Building and submitting command buffers to the GPU queue</SYSTEM>

# Command Encoders and Submission

## Overview [Section titled “Overview”](#overview) WebGPU employs a command buffer architecture where GPU operations are recorded and then executed. Unlike immediate-mode graphics APIs, WebGPU follows a deferred execution model: you create a command encoder, record commands into it, finish to produce a command buffer, and submit to the device queue. ## Command Buffer Lifecycle [Section titled “Command Buffer Lifecycle”](#command-buffer-lifecycle) | Stage | Description | | -------------- | ----------------------------------------------------------- | | **Recording** | Create a command encoder and call methods to add operations | | **Finishing** | Call `encoder.finish()` to produce a GPUCommandBuffer | | **Submission** | Pass command buffers to `queue.submit()` | | **Execution** | GPU processes commands; buffers are single-use | ## Creating Command Encoders [Section titled “Creating Command Encoders”](#creating-command-encoders) Create command encoder ```javascript const encoder = device.createCommandEncoder({ label: "main-render-encoder", }); ``` ## Render Pass Commands [Section titled “Render Pass Commands”](#render-pass-commands) Render passes are bounded regions that specify which textures receive output and how their contents are handled. ### Beginning a Render Pass [Section titled “Beginning a Render Pass”](#beginning-a-render-pass) Render pass with depth ```javascript const renderPassDescriptor = { label: "main-render-pass", colorAttachments: [{ view: context.getCurrentTexture().createView(), clearValue: { r: 0.0, g: 0.0, b: 0.2, a: 1.0 }, loadOp: "clear", storeOp: "store", }], depthStencilAttachment: { view: depthTexture.createView(), depthClearValue: 1.0, depthLoadOp: "clear", depthStoreOp: "store", }, }; const passEncoder = encoder.beginRenderPass(renderPassDescriptor); ``` ### Color Attachments [Section titled “Color Attachments”](#color-attachments) | Property | Description | | --------------- | ----------------------------------------- | | `view` | GPUTextureView to render into | | `resolveTarget` | Optional, for multisample resolve | | `clearValue` | Color to clear if loadOp is ‘clear’ | | `loadOp` | `'clear'` or `'load'` (preserve existing) | | `storeOp` | `'store'` or `'discard'` | Multiple color attachments (up to 8) enable deferred rendering: Multiple render targets ```javascript colorAttachments: [ { view: albedoView, loadOp: "clear", storeOp: "store" }, { view: normalView, loadOp: "clear", storeOp: "store" }, { view: depthView, loadOp: "clear", storeOp: "store" }, ] ``` ### Depth-Stencil Attachment [Section titled “Depth-Stencil Attachment”](#depth-stencil-attachment) Only one depth-stencil attachment per pass: | Property | Description | | ------------------------------- | ----------------------- | | `depthLoadOp/depthStoreOp` | Depth buffer handling | | `stencilLoadOp/stencilStoreOp` | Stencil buffer handling | | `depthClearValue` | Typically 1.0 or 0.0 | | `stencilClearValue` | Typically 0 | | `depthReadOnly/stencilReadOnly` | Mark as read-only | ### Drawing Commands [Section titled “Drawing Commands”](#drawing-commands) Drawing commands ```javascript passEncoder.setPipeline(renderPipeline); passEncoder.setBindGroup(0, bindGroup); passEncoder.setVertexBuffer(0, vertexBuffer); passEncoder.setIndexBuffer(indexBuffer, "uint16"); // Non-indexed drawing passEncoder.draw(vertexCount, instanceCount, firstVertex, firstInstance); // Indexed drawing passEncoder.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance); // Indirect drawing (parameters from GPU buffer) passEncoder.drawIndirect(indirectBuffer, indirectOffset); passEncoder.drawIndexedIndirect(indirectBuffer, indirectOffset); ``` Caution End the pass before encoding more commands. After `end()`, the pass encoder is invalid. ```javascript passEncoder.end(); ``` ## Compute Pass Commands [Section titled “Compute Pass Commands”](#compute-pass-commands) Compute passes execute general-purpose GPU computation. Compute pass with timestamp ```javascript const computePassDescriptor = { label: "particle-update-pass", timestampWrites: { querySet: timestampQuerySet, beginningOfPassWriteIndex: 0, endOfPassWriteIndex: 1, }, }; const passEncoder = encoder.beginComputePass(computePassDescriptor); passEncoder.setPipeline(computePipeline); passEncoder.setBindGroup(0, computeBindGroup); // Dispatch workgroups passEncoder.dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ); // Or indirect dispatch passEncoder.dispatchWorkgroupsIndirect(indirectBuffer, indirectOffset); passEncoder.end(); ``` ## Copy Commands [Section titled “Copy Commands”](#copy-commands) Copy operations transfer data between resources without shaders, often using specialized hardware (DMA engines). ### Buffer to Buffer [Section titled “Buffer to Buffer”](#buffer-to-buffer) Buffer copy ```javascript encoder.copyBufferToBuffer( sourceBuffer, sourceOffset, // bytes, multiple of 4 destinationBuffer, destinationOffset, // bytes, multiple of 4 size // bytes, multiple of 4 ); ``` ### Texture to Texture [Section titled “Texture to Texture”](#texture-to-texture) Texture copy ```javascript encoder.copyTextureToTexture( { texture: sourceTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } }, { texture: destinationTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } }, { width: 512, height: 512, depthOrArrayLayers: 1 } ); ``` ### Buffer to/from Texture [Section titled “Buffer to/from Texture”](#buffer-tofrom-texture) Texture upload and readback ```javascript // Upload texture data encoder.copyBufferToTexture( { buffer: stagingBuffer, offset: 0, bytesPerRow: 256 * 4, rowsPerImage: 256 }, { texture: targetTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } }, { width: 256, height: 256, depthOrArrayLayers: 1 } ); // Readback texture data encoder.copyTextureToBuffer( { texture: sourceTexture, mipLevel: 0, origin: { x: 0, y: 0, z: 0 } }, { buffer: readbackBuffer, offset: 0, bytesPerRow: 256 * 4, rowsPerImage: 256 }, { width: 256, height: 256, depthOrArrayLayers: 1 } ); ``` ## Finishing and Submission [Section titled “Finishing and Submission”](#finishing-and-submission) Finish and submit ```javascript const commandBuffer = encoder.finish({ label: "main-command-buffer", }); device.queue.submit([commandBuffer]); ``` Single-Use Buffers The encoder becomes invalid after `finish()`. Command buffers are single-use—submit once, then discard. ### Multiple Command Buffers [Section titled “Multiple Command Buffers”](#multiple-command-buffers) ### Direct Queue Writes [Section titled “Direct Queue Writes”](#direct-queue-writes) For convenience, write data directly without command encoders: Direct queue writes ```javascript device.queue.writeBuffer(targetBuffer, bufferOffset, arrayBufferData, dataOffset, size); device.queue.writeTexture( { texture: targetTexture, mipLevel: 0 }, imageData, { bytesPerRow: 256 * 4, rowsPerImage: 256 }, { width: 256, height: 256, depthOrArrayLayers: 1 } ); ``` ### Waiting for Completion [Section titled “Waiting for Completion”](#waiting-for-completion) Wait for GPU ```javascript await device.queue.onSubmittedWorkDone(); console.log("All GPU work completed"); ``` ## Synchronization [Section titled “Synchronization”](#synchronization) WebGPU handles synchronization through implicit barriers between passes and command buffers. ### Resource State Tracking [Section titled “Resource State Tracking”](#resource-state-tracking) | Rule | Description | | ------------------------ | ----------------------------------------------------------------------- | | Exclusive write | Resource used for writing cannot be read/written elsewhere in same pass | | Multiple read | Resources can be read from multiple bind groups simultaneously | | Subresource independence | Different mip levels or array layers can be used independently | ### Write-After-Read Safety [Section titled “Write-After-Read Safety”](#write-after-read-safety) Within a command buffer, writes followed by reads are automatically synchronized: Automatic synchronization ```javascript encoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, 256); const computePass = encoder.beginComputePass(); computePass.setBindGroup(0, bindGroupUsingDstBuffer); computePass.dispatchWorkgroups(1); computePass.end(); ``` Between passes, all writes complete before subsequent reads: Pass-to-pass synchronization ```javascript const renderPass = encoder.beginRenderPass(/* writes to texture */); renderPass.end(); const computePass = encoder.beginComputePass(); // Can safely read the texture written above computePass.end(); ``` ## Complete Render Loop [Section titled “Complete Render Loop”](#complete-render-loop) Full render loop example ```javascript async function init() { const adapter = await navigator.gpu.requestAdapter(); const device = await adapter.requestDevice(); const canvas = document.querySelector("canvas"); const context = canvas.getContext("webgpu"); const format = navigator.gpu.getPreferredCanvasFormat(); context.configure({ device, format, alphaMode: "opaque" }); const pipeline = device.createRenderPipeline({ label: "render-pipeline", layout: "auto", vertex: { module: device.createShaderModule({ code: ` @vertex fn vertexMain(@builtin(vertex_index) i: u32) -> @builtin(position) vec4f { const pos = array( vec2f(-0.5, -0.5), vec2f( 0.5, -0.5), vec2f( 0.0, 0.5) ); return vec4f(pos[i], 0.0, 1.0); } `, }), entryPoint: "vertexMain", }, fragment: { module: device.createShaderModule({ code: ` @fragment fn fragmentMain() -> @location(0) vec4f { return vec4f(1.0, 0.5, 0.2, 1.0); } `, }), entryPoint: "fragmentMain", targets: [{ format }], }, primitive: { topology: "triangle-list" }, }); function frame() { const encoder = device.createCommandEncoder({ label: "frame-encoder" }); const pass = encoder.beginRenderPass({ label: "main-render-pass", colorAttachments: [{ view: context.getCurrentTexture().createView(), clearValue: { r: 0.1, g: 0.1, b: 0.15, a: 1.0 }, loadOp: "clear", storeOp: "store", }], }); pass.setPipeline(pipeline); pass.draw(3); pass.end(); device.queue.submit([encoder.finish()]); requestAnimationFrame(frame); } frame(); } init(); ```