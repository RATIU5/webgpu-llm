<SYSTEM>WGSL Shading Language: The WebGPU Shading Language syntax, data types, and functions</SYSTEM>

# WGSL Shading Language

## Overview [Section titled “Overview”](#overview) WGSL (WebGPU Shading Language) is the shading language for WebGPU, designed to be safe, expressive, and portable across GPU architectures. Drawing from Rust’s syntax and safety principles, WGSL provides strong typing, eliminates undefined behavior, and compiles to SPIR-V, Metal Shading Language, or DXIL for cross-platform execution. ## Scalar Types [Section titled “Scalar Types”](#scalar-types) ### Boolean [Section titled “Boolean”](#boolean) Boolean values ```wgsl var is_active: bool = true; var should_render: bool = false; ``` ### Integers [Section titled “Integers”](#integers) 32-bit signed (`i32`) and unsigned (`u32`) integers: Integer types ```wgsl var signed_value: i32 = -42; var unsigned_value: u32 = 100u; // 'u' suffix for unsigned var sum: i32 = signed_value + 10; var product: u32 = unsigned_value * 2u; ``` ### Floating-Point [Section titled “Floating-Point”](#floating-point) Float values ```wgsl var pi: f32 = 3.14159265; var speed_of_light: f32 = 2.998e8; // Scientific notation ``` ### f16 (Optional Feature) [Section titled “f16 (Optional Feature)”](#f16-optional-feature) Half-precision floats ```wgsl enable f16; var half_precision: f16 = 1.5h; ``` ### Type Casting [Section titled “Type Casting”](#type-casting) WGSL requires explicit type conversions: Explicit type conversion ```wgsl var int_value: i32 = 42; var float_value: f32 = f32(int_value); var unsigned_value: u32 = u32(int_value); ``` ## Vector Types [Section titled “Vector Types”](#vector-types) Vectors represent positions, colors, and directions with 2, 3, or 4 components. ### Declaration [Section titled “Declaration”](#declaration) Vector declarations ```wgsl // Explicit types var position: vec3<f32> = vec3<f32>(1.0, 2.0, 3.0); var color: vec4<f32> = vec4<f32>(1.0, 0.5, 0.0, 1.0); // Shorthand types var pos2: vec2f = vec2f(1.0, 2.0); var pos3: vec3f = vec3f(1.0, 2.0, 3.0); var offset: vec3i = vec3i(0, 1, -1); var mask: vec4u = vec4u(1u, 1u, 0u, 1u); ``` ### Constructors [Section titled “Constructors”](#constructors) Vector construction ```wgsl // Scalar broadcast var ones: vec3f = vec3f(1.0); // (1.0, 1.0, 1.0) // Mixed construction var xy: vec2f = vec2f(1.0, 2.0); var xyz: vec3f = vec3f(xy, 3.0); // (1.0, 2.0, 3.0) var xyzw: vec4f = vec4f(xy, 3.0, 4.0); ``` ### Swizzling [Section titled “Swizzling”](#swizzling) Access and rearrange components using `xyzw` or `rgba`: Component swizzling ```wgsl var position: vec4f = vec4f(1.0, 2.0, 3.0, 4.0); var x: f32 = position.x; var xy: vec2f = position.xy; var zyx: vec3f = position.zyx; // Reversed var xxx: vec3f = position.xxx; // Repeated var color: vec4f = vec4f(1.0, 0.5, 0.0, 1.0); var rgb: vec3f = color.rgb; var bgr: vec3f = color.bgr; ``` Caution Do not mix `xyzw` and `rgba` in the same swizzle. ### Operations [Section titled “Operations”](#operations) Vector operations ```wgsl var a: vec3f = vec3f(1.0, 2.0, 3.0); var b: vec3f = vec3f(4.0, 5.0, 6.0); var sum: vec3f = a + b; // Component-wise var product: vec3f = a * b; // Component-wise var scaled: vec3f = a * 2.0; // Scalar multiply var len: f32 = length(a); var normalized: vec3f = normalize(a); var d: f32 = dot(a, b); var cross_prod: vec3f = cross(a, b); // vec3 only ``` ## Matrix Types [Section titled “Matrix Types”](#matrix-types) Matrices are used for transformations. WGSL uses column-major storage. Identity matrix ```wgsl var transform: mat4x4f = mat4x4f( 1.0, 0.0, 0.0, 0.0, // Column 0 0.0, 1.0, 0.0, 0.0, // Column 1 0.0, 0.0, 1.0, 0.0, // Column 2 0.0, 0.0, 0.0, 1.0 // Column 3 ); ``` Column-Major Storage Values are stored by column, not row. This is a common source of confusion: ```wgsl var m: mat3x3f = mat3x3f( 1.0, 2.0, 3.0, // Column 0 (not row!) 4.0, 5.0, 6.0, // Column 1 7.0, 8.0, 9.0 // Column 2 ); // Represents: // [ 1.0 4.0 7.0 ] // [ 2.0 5.0 8.0 ] // [ 3.0 6.0 9.0 ] var col0: vec3f = m[0]; // (1.0, 2.0, 3.0) var element: f32 = m[1][2]; // Column 1, row 2 = 6.0 ``` ### Matrix Operations [Section titled “Matrix Operations”](#matrix-operations) Matrix operations ```wgsl var mat_a: mat4x4f = mat4x4f(/* ... */); var position: vec4f = vec4f(1.0, 2.0, 3.0, 1.0); var combined: mat4x4f = mat_a * mat_b; var transformed: vec4f = mat_a * position; var transposed: mat4x4f = transpose(mat_a); ``` ## Arrays and Structs [Section titled “Arrays and Structs”](#arrays-and-structs) ### Fixed-Size Arrays [Section titled “Fixed-Size Arrays”](#fixed-size-arrays) Fixed-size array ```wgsl var colors: array<vec3f, 4> = array<vec3f, 4>( vec3f(1.0, 0.0, 0.0), vec3f(0.0, 1.0, 0.0), vec3f(0.0, 0.0, 1.0), vec3f(1.0, 1.0, 0.0) ); var first: vec3f = colors[0]; ``` ### Runtime-Sized Arrays [Section titled “Runtime-Sized Arrays”](#runtime-sized-arrays) Only allowed as the last member of a struct in storage buffers: Runtime-sized array in storage ```wgsl struct ParticleBuffer { count: u32, particles: array<vec4f> } @group(0) @binding(0) var<storage, read> data: ParticleBuffer; ``` ### Structs [Section titled “Structs”](#structs) Struct definitions ```wgsl struct Vertex { position: vec3f, normal: vec3f, uv: vec2f, color: vec4f } struct Light { position: vec3f, color: vec3f, intensity: f32, radius: f32 } var light: Light = Light( vec3f(10.0, 10.0, 10.0), vec3f(1.0, 1.0, 1.0), 100.0, 50.0 ); ``` ## Memory Alignment [Section titled “Memory Alignment”](#memory-alignment) WGSL enforces strict alignment rules that differ from typical CPU layouts. | Type | Alignment | | ------------------- | ------------------------------------- | | `f32`, `i32`, `u32` | 4 bytes | | `vec2<T>` | 8 bytes | | `vec3<T>` | **16 bytes** (despite being 12 bytes) | | `vec4<T>` | 16 bytes | | `mat4x4<f32>` | 16 bytes | The vec3 Padding Issue `vec3` aligns to 16 bytes, causing unexpected struct sizes: ```wgsl // Problematic layout struct TwoVec3s { a: vec3f, // Offset 0, size 12, padded to 16 b: vec3f // Offset 16, size 12, padded to 16 } // Total: 32 bytes (not 24) // Solution: Use vec4 or explicit padding struct BetterLayout { a: vec4f, // Set w to 0.0 if unused b: vec4f } ``` ## Functions [Section titled “Functions”](#functions) Function syntax ```wgsl fn add(a: f32, b: f32) -> f32 { return a + b; } fn transform_point(point: vec3f, matrix: mat4x4f, scale: f32) -> vec3f { let transformed = matrix * vec4f(point, 1.0); return transformed.xyz * scale; } ``` Parameters are passed by value. For multiple return values, use a struct. ### Entry Points [Section titled “Entry Points”](#entry-points) Shader entry points ```wgsl @vertex fn vertex_main(@builtin(vertex_index) idx: u32) -> @builtin(position) vec4f { var positions = array<vec2f, 3>( vec2f(0.0, 0.5), vec2f(-0.5, -0.5), vec2f(0.5, -0.5) ); return vec4f(positions[idx], 0.0, 1.0); } @fragment fn fragment_main(@builtin(position) coord: vec4f) -> @location(0) vec4f { return vec4f(1.0, 0.5, 0.0, 1.0); } @compute @workgroup_size(8, 8, 1) fn compute_main(@builtin(global_invocation_id) id: vec3u) { let index = id.x + id.y * 256u; } ``` ## Attributes [Section titled “Attributes”](#attributes) ### @location [Section titled “@location”](#location) Shader stage inputs and outputs: Location attributes ```wgsl struct VertexInput { @location(0) position: vec3f, @location(1) normal: vec3f, @location(2) uv: vec2f } struct VertexOutput { @builtin(position) clip_position: vec4f, @location(0) world_normal: vec3f, @location(1) tex_coords: vec2f } ``` ### @group and @binding [Section titled “@group and @binding”](#group-and-binding) Resource bindings: Resource bindings ```wgsl @group(0) @binding(0) var<uniform> camera: CameraUniforms; @group(0) @binding(1) var<storage, read> vertices: array<Vertex>; @group(0) @binding(2) var<storage, read_write> output: array<vec4f>; @group(1) @binding(0) var my_texture: texture_2d<f32>; @group(1) @binding(1) var my_sampler: sampler; ``` ### @builtin [Section titled “@builtin”](#builtin) ### @workgroup\_size [Section titled “@workgroup\_size”](#workgroup_size) Workgroup size examples ```wgsl @compute @workgroup_size(256) fn compute_1d(@builtin(global_invocation_id) id: vec3u) { } @compute @workgroup_size(16, 16) fn compute_2d(@builtin(global_invocation_id) id: vec3u) { } @compute @workgroup_size(8, 8, 4) fn compute_3d(@builtin(global_invocation_id) id: vec3u) { } ``` ## Control Flow [Section titled “Control Flow”](#control-flow) ### Conditionals [Section titled “Conditionals”](#conditionals) If/else statements ```wgsl fn classify(x: f32) -> i32 { if (x > 0.0) { return 1; } else if (x < 0.0) { return -1; } else { return 0; } } ``` ### Switch [Section titled “Switch”](#switch) Switch statement ```wgsl fn get_color(channel: u32) -> vec3f { switch (channel) { case 0u: { return vec3f(1.0, 0.0, 0.0); } case 1u: { return vec3f(0.0, 1.0, 0.0); } case 2u: { return vec3f(0.0, 0.0, 1.0); } default: { return vec3f(0.0, 0.0, 0.0); } } } // Multiple cases switch (channel) { case 0u, 1u, 2u: { return true; } default: { return false; } } ``` ### Loops [Section titled “Loops”](#loops) Loop constructs ```wgsl // For loop for (var i = 0; i < 100; i++) { sum += data[i]; } // While loop while (value < threshold) { value += 0.1; count++; } // Loop with break loop { if (i >= 10) { break; } i++; } ``` ### Loop with Continuing [Section titled “Loop with Continuing”](#loop-with-continuing) The `continuing` block executes at the end of each iteration (like `for` loop increment): Loop with continuing block ```wgsl var i = 0; loop { if (i >= 10) { break; } // Loop body sum += data[i]; continuing { i++; // Executes after each iteration } } ``` ### break if [Section titled “break if”](#break-if) Early exit with condition in `continuing` block: break if syntax ```wgsl var i = 0; loop { sum += data[i]; continuing { i++; break if i >= limit; // Exit after continuing } } ``` ### continue [Section titled “continue”](#continue) Skip to next iteration: continue statement ```wgsl for (var i = 0; i < 100; i++) { if (data[i] < 0.0) { continue; // Skip negative values } sum += data[i]; } ``` ### select() [Section titled “select()”](#select) Branchless conditional (often faster than `if`): Branchless select ```wgsl var max_val = select(a, b, b > a); // b > a ? b : a var clamped = select(x, 0.0, x < 0.0); // Component-wise for vectors var max_vec = select(a_vec, b_vec, b_vec > a_vec); ``` ### discard [Section titled “discard”](#discard) Kill fragment in fragment shaders: Alpha test with discard ```wgsl @fragment fn alpha_test(@location(0) uv: vec2f) -> @location(0) vec4f { let color = textureSample(tex, samp, uv); if (color.a < 0.5) { discard; } return color; } ``` ## Built-in Functions [Section titled “Built-in Functions”](#built-in-functions) ### Synchronization [Section titled “Synchronization”](#synchronization) Workgroup barrier ```wgsl var<workgroup> shared: array<f32, 256>; @compute @workgroup_size(256) fn compute(@builtin(local_invocation_index) idx: u32) { shared[idx] = f32(idx); workgroupBarrier(); // Wait for all writes let neighbor = shared[(idx + 1u) % 256u]; } ``` ### Atomics [Section titled “Atomics”](#atomics) Atomic operations ```wgsl @group(0) @binding(0) var<storage, read_write> counter: atomic<u32>; @compute @workgroup_size(64) fn atomic_ops(@builtin(global_invocation_id) id: vec3u) { let old = atomicAdd(&counter, 1u); atomicSub(&counter, 1u); atomicMax(&counter, 100u); atomicMin(&counter, 0u); atomicExchange(&counter, 42u); } ``` ## Uniformity Requirements [Section titled “Uniformity Requirements”](#uniformity-requirements) Uniform Control Flow Required Texture sampling with implicit derivatives requires uniform control flow—all threads in a group must take the same path: ```wgsl // ✗ Invalid: non-uniform control flow @fragment fn bad(@location(0) uv: vec2f, @location(1) flag: f32) -> @location(0) vec4f { if (flag > 0.5) { // Non-uniform! return textureSample(tex, samp, uv); // Error } return vec4f(0.0); } // ✓ Valid: sample unconditionally, then select @fragment fn good(@location(0) uv: vec2f, @location(1) flag: f32) -> @location(0) vec4f { let sampled = textureSample(tex, samp, uv); return select(vec4f(0.0), sampled, flag > 0.5); } ``` ## Performance Tips [Section titled “Performance Tips”](#performance-tips) ## Pointers and References [Section titled “Pointers and References”](#pointers-and-references) WGSL supports pointers for passing variables by reference. ### Pointer Syntax [Section titled “Pointer Syntax”](#pointer-syntax) Pointer types ```wgsl // ptr<address_space, type, access_mode> fn increment(p: ptr<function, i32>) { *p = *p + 1; // Dereference with * } fn main() { var x: i32 = 5; increment(&x); // Pass address with & // x is now 6 } ``` ### Address Spaces [Section titled “Address Spaces”](#address-spaces) | Space | Description | Pointer Access | | ----------- | ----------------------- | --------------------------------------- | | `function` | Local variables | `ptr<function, T>` | | `private` | Per-invocation globals | `ptr<private, T>` | | `workgroup` | Shared within workgroup | `ptr<workgroup, T>` | | `storage` | Buffer storage | `ptr<storage, T, read>` or `read_write` | | `uniform` | Uniform buffer | `ptr<uniform, T>` | Storage pointer example ```wgsl fn process(data: ptr<storage, array<f32>, read_write>, idx: u32) { (*data)[idx] *= 2.0; } ``` Pointer Restrictions * Cannot store pointers in variables (no pointer-to-pointer) * Cannot return pointers from functions * Pointers must point to concrete memory locations ## Constants and Overrides [Section titled “Constants and Overrides”](#constants-and-overrides) ### const [Section titled “const”](#const) Compile-time constant expressions: const declarations ```wgsl const PI: f32 = 3.14159265; const TAU: f32 = PI * 2.0; const WORKGROUP_SIZE: u32 = 256u; // Const arrays const VERTICES: array<vec2f, 3> = array<vec2f, 3>( vec2f(0.0, 0.5), vec2f(-0.5, -0.5), vec2f(0.5, -0.5) ); ``` ### override [Section titled “override”](#override) Pipeline-overridable constants (set at pipeline creation): override declarations ```wgsl @id(0) override BLOCK_SIZE: u32 = 64u; @id(1) override THRESHOLD: f32 = 0.5; override USE_FAST_PATH: bool = true; // ID auto-assigned @compute @workgroup_size(BLOCK_SIZE) fn main() { if (USE_FAST_PATH) { // Fast path } } ``` Override at pipeline creation ```javascript const pipeline = device.createComputePipeline({ layout: "auto", compute: { module: shaderModule, entryPoint: "main", constants: { 0: 128, // BLOCK_SIZE = 128 1: 0.75, // THRESHOLD = 0.75 }, }, }); ``` ### const\_assert [Section titled “const\_assert”](#const_assert) Compile-time assertions for catching errors early: const\_assert examples ```wgsl const BUFFER_SIZE: u32 = 1024u; const_assert BUFFER_SIZE >= 256u; // Fails compilation if false const_assert BUFFER_SIZE % 64u == 0u; // Must be multiple of 64 // Validate struct alignment const_assert sizeof(MyStruct) == 64u; ``` ## Resources [Section titled “Resources”](#resources)