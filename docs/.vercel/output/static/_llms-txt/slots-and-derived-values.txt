<SYSTEM>Slots and Derived Values: Dynamic resource binding with slots and computed values with derived</SYSTEM>

# Slots and Derived Values

## Overview [Section titled “Overview”](#overview) TypeGPU provides **slots** for dynamic resource management and **derived values** for reactive computation patterns. These features enable runtime resource switching without shader recompilation. ## Creating Slots [Section titled “Creating Slots”](#creating-slots) Slot creation ```typescript import tgpu from "typegpu"; import * as d from "typegpu/data"; // Scalar slots const timeSlot = tgpu.slot(d.f32); const scaleSlot = tgpu.slot(d.f32, 1.0); // With default // Vector/matrix slots const colorSlot = tgpu.slot(d.vec3f); const transformSlot = tgpu.slot(d.mat4x4f); // Texture/sampler slots const textureSlot = tgpu.slot(d.texture2d(d.f32)); const samplerSlot = tgpu.slot("filtering"); // Structured data const materialSlot = tgpu.slot(d.struct({ albedo: d.vec3f, metallic: d.f32, roughness: d.f32, })); ``` ## Using Slots in Shaders [Section titled “Using Slots in Shaders”](#using-slots-in-shaders) Access slots with `.value` (or `$` alias) and declare dependencies with `$uses`: Slots in TGSL ```typescript const timeSlot = tgpu.slot(d.f32, 0.0); const colorSlot = tgpu.slot(d.vec3f); const textureSlot = tgpu.slot(d.texture2d(d.f32)); const samplerSlot = tgpu.slot("filtering"); const fragmentShader = tgpu.fn([d.vec2f], d.vec4f) .$uses({ time: timeSlot, tint: colorSlot, tex: textureSlot, smp: samplerSlot }) ((uv) => { "use gpu"; const texColor = textureSample(textureSlot.value, samplerSlot.value, uv); const pulse = (Math.sin(timeSlot.value) + 1.0) * 0.5; return d.vec4f(texColor.rgb * colorSlot.value * pulse, texColor.a); }); ``` ## Runtime Resource Binding [Section titled “Runtime Resource Binding”](#runtime-resource-binding) Bind slots with `.with()` before pipeline execution: Binding slots ```typescript const renderPipeline = root["~unstable"] .withVertex(vertexFn, vertexLayout) .withFragment(fragmentFn, { color: format }) .createPipeline(); renderPipeline .with(bindGroup) .with(timeSlot, currentTime) .with(colorSlot, vec3(1.0, 0.5, 0.2)) .with(textureSlot, myTexture) .with(samplerSlot, mySampler) .withColorAttachment({ color: colorTarget }) .draw(vertexCount); ``` ### Switching Resources Between Draws [Section titled “Switching Resources Between Draws”](#switching-resources-between-draws) Dynamic material switching ```typescript // Red material renderPipeline .with(colorSlot, vec3(1.0, 0.0, 0.0)) .with(textureSlot, texture1) .withColorAttachment({ color: output }) .draw(vertexCount); // Blue material - no pipeline recreation renderPipeline .with(colorSlot, vec3(0.0, 0.0, 1.0)) .with(textureSlot, texture2) .withColorAttachment({ color: output }) .draw(vertexCount); ``` ## Derived Values [Section titled “Derived Values”](#derived-values) Unstable API Derived values are under `~unstable` namespace and may change in future versions. Derived values compute automatically from dependencies: Reactive computation ```typescript const widthSlot = tgpu.slot(d.f32, 1920); const heightSlot = tgpu.slot(d.f32, 1080); // Automatically recalculates when width/height change const aspectRatio = tgpu["~unstable"].derived(() => { return widthSlot.value / heightSlot.value; }); const invResolution = tgpu["~unstable"].derived(() => { return d.vec2f(1.0 / widthSlot.value, 1.0 / heightSlot.value); }); ``` ### Dependency Chains [Section titled “Dependency Chains”](#dependency-chains) Chained derived values ```typescript const timeSlot = tgpu.slot(d.f32); const speedSlot = tgpu.slot(d.f32, 1.0); // Depends on timeSlot and speedSlot const animatedOffset = tgpu["~unstable"].derived(() => { return Math.sin(timeSlot.value * speedSlot.value); }); // Depends on animatedOffset const animatedColor = tgpu["~unstable"].derived(() => { const t = animatedOffset.value; return d.vec3f(t * 0.5 + 0.5, 0.5, 1.0 - t * 0.5); }); ``` ## Use Cases [Section titled “Use Cases”](#use-cases) ## Performance Guidelines [Section titled “Performance Guidelines”](#performance-guidelines) ### Optimization Strategy [Section titled “Optimization Strategy”](#optimization-strategy) Combine static and dynamic bindings ```typescript // Static for unchanging resources const staticBindGroup = root.createBindGroup(layout, { camera: cameraBuffer, lights: lightBuffer, }); // Slots only for dynamic resources const textureSlot = tgpu.slot(d.texture2d(d.f32)); // Minimize slot changes by sorting objects objects.sort((a, b) => a.materialId - b.materialId); let currentMaterial = null; for (const obj of objects) { if (obj.material !== currentMaterial) { pipeline.with(materialSlot, obj.material); currentMaterial = obj.material; } pipeline.with(transformSlot, obj.transform).draw(obj.vertexCount); } ``` ## Common Pitfalls [Section titled “Common Pitfalls”](#common-pitfalls) Accessing Slots Without .value ```typescript // WRONG const shader = tgpu.fn([], d.f32)(() => { "use gpu"; return timeSlot; // Missing .value }); // CORRECT const shader = tgpu.fn([], d.f32)(() => { "use gpu"; return timeSlot.value; }); ``` Forgetting to Bind Slots ```typescript // WRONG - colorSlot not bound pipeline.withColorAttachment({ color: output }).draw(6); // CORRECT pipeline .with(colorSlot, vec3(1, 0, 0)) .withColorAttachment({ color: output }) .draw(6); ``` Type Mismatches TypeScript catches binding wrong types at compile time: ```typescript const vec3Slot = tgpu.slot(d.vec3f); pipeline.with(vec3Slot, vec4(1, 2, 3, 4)); // Type error pipeline.with(vec3Slot, vec3(1, 2, 3)); // Correct ``` ## Resources [Section titled “Resources”](#resources)