<SYSTEM>Render Pipelines: Vertex shaders, fragment shaders, and the graphics rendering pipeline</SYSTEM>

# Render Pipelines

## Overview [Section titled “Overview”](#overview) Render pipelines define how raw vertex data transforms into pixels on screen. They configure a sequence of programmable and fixed-function stages that process geometry through vertex transformation, rasterization, fragment shading, and output merging. ## Pipeline Stages [Section titled “Pipeline Stages”](#pipeline-stages) ### Vertex Stage [Section titled “Vertex Stage”](#vertex-stage) The first programmable stage—processes each vertex independently: * Transform positions using model-view-projection matrices * Calculate per-vertex lighting (Gouraud shading) * Generate texture coordinates * Pass attributes to the fragment shader Vertex shader output ```wgsl @builtin(position) position: vec4f // Required: clip space position ``` ### Primitive Assembly [Section titled “Primitive Assembly”](#primitive-assembly) Groups vertices into geometric primitives: | Topology | Description | | ---------------- | ---------------------------------------------- | | `triangle-list` | Every 3 vertices form a triangle (most common) | | `triangle-strip` | Shared edges between adjacent triangles | | `line-list` | Pairs of vertices form lines | | `line-strip` | Connected line segments | | `point-list` | Individual points | ### Rasterization [Section titled “Rasterization”](#rasterization) Converts primitives to fragments (potential pixels): 1. Clips primitives to view frustum 2. Performs perspective division 3. Maps to viewport coordinates 4. Determines pixel coverage 5. Interpolates vertex attributes ### Fragment Stage [Section titled “Fragment Stage”](#fragment-stage) Second programmable stage—determines pixel colors: * Samples textures and applies filtering * Calculates lighting (Phong, PBR) * Implements effects (bump mapping, reflections) * Performs alpha testing ### Output Merging [Section titled “Output Merging”](#output-merging) Combines fragment output with existing framebuffer: **Depth Testing**: | Compare | Description | | ------------ | ---------------------------- | | `less` | Standard 3D rendering | | `less-equal` | Same geometry multiple times | | `greater` | Reverse depth buffers | | `always` | Disable depth testing | **Blending**: | Mode | Formula | Use Case | | -------- | ----------------------- | ----------------- | | Opaque | Replace | Solid objects | | Alpha | `src × α + dst × (1-α)` | Transparency | | Additive | `src + dst` | Particles, lights | ## Creating Render Pipelines [Section titled “Creating Render Pipelines”](#creating-render-pipelines) ### Synchronous vs Async [Section titled “Synchronous vs Async”](#synchronous-vs-async) Synchronous creation ```javascript const pipeline = device.createRenderPipeline(descriptor); ``` Async creation (recommended) ```javascript const pipeline = await device.createRenderPipelineAsync(descriptor); ``` ### Complete Pipeline Descriptor [Section titled “Complete Pipeline Descriptor”](#complete-pipeline-descriptor) Full render pipeline ```javascript const pipeline = device.createRenderPipeline({ label: "Main Render Pipeline", layout: "auto", vertex: { module: shaderModule, entryPoint: "vertexMain", buffers: [{ arrayStride: 24, attributes: [ { shaderLocation: 0, offset: 0, format: "float32x3" }, { shaderLocation: 1, offset: 12, format: "float32x3" }, ], }], }, fragment: { module: shaderModule, entryPoint: "fragmentMain", targets: [{ format: navigator.gpu.getPreferredCanvasFormat(), blend: { color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" }, alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, }, }], }, primitive: { topology: "triangle-list", cullMode: "back", frontFace: "ccw", }, depthStencil: { format: "depth24plus", depthWriteEnabled: true, depthCompare: "less", }, }); ``` ## Shader Modules [Section titled “Shader Modules”](#shader-modules) Create shader module ```javascript const shaderModule = device.createShaderModule({ label: "Triangle Shaders", code: ` struct VertexOutput { @builtin(position) position: vec4f, @location(0) color: vec4f, }; @vertex fn vertexMain(@location(0) pos: vec2f, @location(1) color: vec4f) -> VertexOutput { var output: VertexOutput; output.position = vec4f(pos, 0.0, 1.0); output.color = color; return output; } @fragment fn fragmentMain(@location(0) color: vec4f) -> @location(0) vec4f { return color; } `, }); ``` Location Matching Fragment shader inputs must match vertex shader outputs by `@location` number and type: ```wgsl // Vertex output @location(0) color: vec3f, @location(1) texCoord: vec2f, // Fragment input - must match fn fragmentMain(@location(0) color: vec3f, @location(1) texCoord: vec2f) ``` ## Vertex State [Section titled “Vertex State”](#vertex-state) ### Buffer Layouts [Section titled “Buffer Layouts”](#buffer-layouts) Vertex buffer layout ```javascript buffers: [{ arrayStride: 24, // Bytes per vertex stepMode: "vertex", attributes: [ { shaderLocation: 0, offset: 0, format: "float32x3" }, // Position { shaderLocation: 1, offset: 12, format: "float32x3" }, // Normal ], }] ``` ### Attribute Formats [Section titled “Attribute Formats”](#attribute-formats) ### Step Modes [Section titled “Step Modes”](#step-modes) | Mode | Advances | Use Case | | ---------- | ------------ | ------------------- | | `vertex` | Per vertex | Standard attributes | | `instance` | Per instance | Instanced rendering | Instanced rendering layout ```javascript buffers: [ { arrayStride: 12, stepMode: "vertex", attributes: [/* per-vertex */] }, { arrayStride: 16, stepMode: "instance", attributes: [/* per-instance */] }, ] ``` ## Fragment State [Section titled “Fragment State”](#fragment-state) ### Render Targets [Section titled “Render Targets”](#render-targets) Multiple render targets ```javascript targets: [ { format: "rgba16float" }, // Position { format: "rgba16float" }, // Normal { format: "rgba8unorm" }, // Albedo ] ``` ### Blend Configurations [Section titled “Blend Configurations”](#blend-configurations) ## Primitive State [Section titled “Primitive State”](#primitive-state) Primitive configuration ```javascript primitive: { topology: "triangle-list", frontFace: "ccw", // Counter-clockwise = front cullMode: "back", // Cull back faces stripIndexFormat: undefined, } ``` ## Depth/Stencil State [Section titled “Depth/Stencil State”](#depthstencil-state) Depth testing configuration ```javascript depthStencil: { format: "depth24plus", depthWriteEnabled: true, depthCompare: "less", } ``` | Format | Description | | ---------------------- | ----------------------------- | | `depth16unorm` | 16-bit depth | | `depth24plus` | At least 24-bit (recommended) | | `depth32float` | Maximum precision | | `depth24plus-stencil8` | Depth + stencil | Create Depth Texture Depth testing requires a depth texture attached to the render pass: ```javascript const depthTexture = device.createTexture({ size: [canvas.width, canvas.height], format: "depth24plus", usage: GPUTextureUsage.RENDER_ATTACHMENT, }); ``` ## TypeGPU Render Pipelines [Section titled “TypeGPU Render Pipelines”](#typegpu-render-pipelines) ### Builder Pattern [Section titled “Builder Pattern”](#builder-pattern) TypeGPU pipeline builder ```typescript const pipeline = root .withVertex(vertexShader, { position, normal, texCoord }) .withFragment(fragmentShader, { color: { format: "bgra8unorm" } }) .withDepthStencil({ format: "depth24plus", depthCompare: "less", depthWriteEnabled: true }) .withPrimitive({ topology: "triangle-list", cullMode: "back" }) .createPipeline(); ``` ### Vertex Layout [Section titled “Vertex Layout”](#vertex-layout) TypeGPU vertex layout ```typescript const vertexLayout = tgpu.vertexLayout({ position: { format: "float32x3", offset: 0 }, normal: { format: "float32x3", offset: 12 }, texCoord: { format: "float32x2", offset: 24 }, }, { arrayStride: 32, stepMode: "vertex", }); ``` ### Drawing [Section titled “Drawing”](#drawing) TypeGPU draw call ```typescript pipeline .with(vertexLayout, vertexBuffer) .with(uniformBindGroup) .withColorAttachment({ color: { view: context.getCurrentTexture().createView(), loadOp: "clear", clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, storeOp: "store", }, }) .withDepthStencilAttachment({ view: depthTextureView, depthLoadOp: "clear", depthClearValue: 1.0, depthStoreOp: "store", }) .draw(vertexCount); ``` ## Complete Example [Section titled “Complete Example”](#complete-example) Full WebGPU render pipeline ```javascript const shaderModule = device.createShaderModule({ code: ` struct Uniforms { modelViewProjection: mat4x4f }; @group(0) @binding(0) var<uniform> uniforms: Uniforms; struct VertexInput { @location(0) position: vec3f, @location(1) color: vec3f }; struct VertexOutput { @builtin(position) position: vec4f, @location(0) color: vec3f }; @vertex fn vertexMain(input: VertexInput) -> VertexOutput { var output: VertexOutput; output.position = uniforms.modelViewProjection * vec4f(input.position, 1.0); output.color = input.color; return output; } @fragment fn fragmentMain(@location(0) color: vec3f) -> @location(0) vec4f { return vec4f(color, 1.0); } `, }); const pipeline = device.createRenderPipeline({ layout: "auto", vertex: { module: shaderModule, entryPoint: "vertexMain", buffers: [{ arrayStride: 24, attributes: [ { shaderLocation: 0, offset: 0, format: "float32x3" }, { shaderLocation: 1, offset: 12, format: "float32x3" }, ], }], }, fragment: { module: shaderModule, entryPoint: "fragmentMain", targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }], }, primitive: { topology: "triangle-list", cullMode: "back" }, depthStencil: { format: "depth24plus", depthWriteEnabled: true, depthCompare: "less" }, }); // Render const commandEncoder = device.createCommandEncoder(); const renderPass = commandEncoder.beginRenderPass({ colorAttachments: [{ view: context.getCurrentTexture().createView(), loadOp: "clear", clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, storeOp: "store", }], depthStencilAttachment: { view: depthTextureView, depthLoadOp: "clear", depthClearValue: 1.0, depthStoreOp: "store", }, }); renderPass.setPipeline(pipeline); renderPass.setVertexBuffer(0, vertexBuffer); renderPass.setBindGroup(0, bindGroup); renderPass.draw(3); renderPass.end(); device.queue.submit([commandEncoder.finish()]); ``` ## Performance Guidelines [Section titled “Performance Guidelines”](#performance-guidelines) Transparent Objects Transparent rendering requires correct blend state and drawing order: ```javascript depthStencil: { depthWriteEnabled: false, // Don't write depth depthCompare: "less", // Still test depth } ``` ## Resources [Section titled “Resources”](#resources)