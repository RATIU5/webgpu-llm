<SYSTEM>Atomic Operations: Thread-safe operations in compute shaders for concurrent data access</SYSTEM>

# Atomic Operations

## Overview [Section titled “Overview”](#overview) Atomic operations provide thread-safe access to shared memory in GPU compute shaders. When thousands of invocations execute concurrently, atomics guarantee that read-modify-write sequences complete without interference. ## Atomic Types [Section titled “Atomic Types”](#atomic-types) ### Declaration [Section titled “Declaration”](#declaration) Atomic variable declarations ```wgsl // Storage buffer atomics @group(0) @binding(0) var<storage, read_write> counter: atomic<u32>; @group(0) @binding(1) var<storage, read_write> histogram: array<atomic<u32>, 256>; // Workgroup shared atomics var<workgroup> localCounter: atomic<i32>; ``` ### Supported Types [Section titled “Supported Types”](#supported-types) | Type | Description | | ------------- | ----------------------- | | `atomic<u32>` | Unsigned 32-bit integer | | `atomic<i32>` | Signed 32-bit integer | No Float Atomics WGSL does not support `atomic<f32>`. Use fixed-point representation or compare-exchange loops for floating-point atomics. ### Address Space Restrictions [Section titled “Address Space Restrictions”](#address-space-restrictions) Atomics only work in: * `var<storage, read_write>` — Storage buffers * `var<workgroup>` — Workgroup shared memory ## Atomic Operations [Section titled “Atomic Operations”](#atomic-operations) ### Load and Store [Section titled “Load and Store”](#load-and-store) Basic atomic access ```wgsl let value = atomicLoad(&counter); atomicStore(&counter, 42u); ``` ### Arithmetic Operations [Section titled “Arithmetic Operations”](#arithmetic-operations) All return the **previous value**: Atomic arithmetic ```wgsl let old = atomicAdd(&counter, 1u); // Add, return old let old = atomicSub(&counter, 1u); // Subtract, return old let old = atomicMax(&counter, value); // Store max, return old let old = atomicMin(&counter, value); // Store min, return old ``` ### Bitwise Operations [Section titled “Bitwise Operations”](#bitwise-operations) Atomic bitwise ```wgsl let old = atomicAnd(&flags, mask); // AND, return old let old = atomicOr(&flags, mask); // OR, return old let old = atomicXor(&flags, mask); // XOR, return old ``` ### Exchange and Compare-Exchange [Section titled “Exchange and Compare-Exchange”](#exchange-and-compare-exchange) Atomic exchange operations ```wgsl // Simple exchange let old = atomicExchange(&lock, 1u); // Compare and exchange (weak) let result = atomicCompareExchangeWeak(&value, expected, newValue); if (result.exchanged) { // Successfully updated } else { // Failed, result.old_value contains current value } ``` Spurious Failure `atomicCompareExchangeWeak` can fail even when values match. Always check `result.exchanged` and retry in a loop. ## Common Patterns [Section titled “Common Patterns”](#common-patterns) ## Memory Ordering [Section titled “Memory Ordering”](#memory-ordering) ### Acquire-Release Semantics [Section titled “Acquire-Release Semantics”](#acquire-release-semantics) * **Atomic write** (release): All prior memory ops complete before write visible * **Atomic read** (acquire): Read completes before subsequent memory ops begin ### Synchronization with Barriers [Section titled “Synchronization with Barriers”](#synchronization-with-barriers) Combining atomics with barriers ```wgsl var<workgroup> ready: atomic<u32>; var<workgroup> data: f32; @compute @workgroup_size(64) fn process(@builtin(local_invocation_index) idx: u32) { if (idx == 0u) { data = 42.0; workgroupBarrier(); // Ensure write completes atomicStore(&ready, 1u); } // Consumer threads if (idx > 0u) { loop { if (atomicLoad(&ready) == 1u) { break; } } workgroupBarrier(); // Ensure we see data write let value = data; } } ``` ## Performance Considerations [Section titled “Performance Considerations”](#performance-considerations) ### Throughput Impact [Section titled “Throughput Impact”](#throughput-impact) | Operation | Relative Cost | | ------------------------ | ------------- | | Regular memory | 1× | | Atomic (low contention) | 10-100× | | Atomic (high contention) | 100-1000× | ## TypeGPU Atomic Support [Section titled “TypeGPU Atomic Support”](#typegpu-atomic-support) TypeGPU atomic types ```typescript import { d } from "typegpu/data"; import { std } from "typegpu/std"; const atomicCounter = d.atomic(d.u32); const CounterBuffer = d.struct({ hitCount: d.atomic(d.u32), missCount: d.atomic(d.u32), }); // In shader const shader = tgpu.computeFn([counterBuffer], () => { const old = std.atomicAdd(counterBuffer.value.hitCount, 1); }); ``` ## Common Pitfalls [Section titled “Common Pitfalls”](#common-pitfalls) Race on Non-Atomic Data ```wgsl // Atomics only protect the atomic variable itself! let idx = atomicAdd(&counter, 1u); data[idx] = value; // data array is NOT protected // Use workgroupBarrier() after atomics if other threads read data ``` Spinlock Deadlock ```wgsl // DANGEROUS: GPU threads in same warp execute in lockstep loop { if (atomicExchange(&lock, 1u) == 0u) { break; } } // One thread holding lock blocks others in same warp forever ``` **Solution**: Avoid locks on GPUs. Redesign for lock-free algorithms. Missing Barrier for Non-Atomic Memory ```wgsl // Thread A result = 42.0; atomicStore(&ready, 1u); // Thread B - might see old value! if (atomicLoad(&ready) == 1u) { let value = result; // Not guaranteed to be 42.0 } // Fix: Add workgroupBarrier() before and after the atomic ``` Unnecessary Atomics ```wgsl // Bad: Atomic when each thread writes unique location atomicStore(&output[gid.x], value); // Good: Regular store is sufficient output[gid.x] = value; ``` ## Resources [Section titled “Resources”](#resources)