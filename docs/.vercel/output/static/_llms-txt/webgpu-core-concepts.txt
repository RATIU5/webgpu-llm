<SYSTEM>WebGPU Core Concepts: Understanding GPUAdapter, GPUDevice, GPUQueue, and the WebGPU architecture</SYSTEM>

# WebGPU Core Concepts

## Overview [Section titled “Overview”](#overview) WebGPU is a modern graphics and compute API for the web that provides low-level, high-performance access to GPU hardware. Designed from the ground up to align with contemporary GPU architecture, WebGPU maps efficiently to native APIs including Vulkan (cross-platform), Metal (Apple), and Direct3D 12 (Windows). WebGPU enables high-fidelity 3D rendering with advanced techniques like physically-based rendering and complex post-processing pipelines. It treats general-purpose GPU computation (GPGPU) as a first-class feature, making it suitable for machine learning inference, scientific simulations, data visualization, and video processing. ## GPUAdapter: Hardware Abstraction [Section titled “GPUAdapter: Hardware Abstraction”](#gpuadapter-hardware-abstraction) The GPUAdapter represents physical GPU hardware and serves as the entry point for capability discovery. It abstracts the underlying graphics hardware and driver while exposing machine capabilities through a privacy-conscious binning mechanism. Requesting an adapter ```typescript const adapter = await navigator.gpu.requestAdapter({ powerPreference: "high-performance", forceFallbackAdapter: false, }); if (!adapter) { throw new Error("WebGPU adapter not available"); } ``` ### Querying Capabilities [Section titled “Querying Capabilities”](#querying-capabilities) Adapters expose capabilities through two interfaces: Checking features and limits ```typescript // Feature enumeration - optional capabilities as strings console.log("Features:", Array.from(adapter.features)); if (adapter.features.has("texture-compression-bc")) { // BC compressed textures supported } // Capability limits - numeric constraints console.log("Max texture size:", adapter.limits.maxTextureDimension2D); console.log("Max buffer size:", adapter.limits.maxBufferSize); ``` ## GPUDevice: Logical Connection [Section titled “GPUDevice: Logical Connection”](#gpudevice-logical-connection) The GPUDevice is a logical connection to the GPU through which almost all WebGPU operations are performed. While the adapter represents physical hardware, the device provides an isolated, secure interface for creating resources and submitting work. Creating a device with features ```typescript const device = await adapter.requestDevice({ requiredFeatures: ["texture-compression-bc"], requiredLimits: { maxStorageBufferBindingSize: 512 * 1024 * 1024, }, }); ``` Feature Requests If any requested feature is unavailable or any limit exceeds the adapter’s maximum, the Promise rejects. Always check adapter capabilities before requesting. The device manages all GPU resources: * **Buffers** — GPU-accessible memory * **Textures** — Image data * **Shader modules** — Compiled WGSL * **Pipelines** — Complete rendering/compute state * **Bind groups** — Resource binding configuration ### Device Lost Handling [Section titled “Device Lost Handling”](#device-lost-handling) A device can become “lost” due to GPU driver crashes, system sleep/wake cycles, or hardware removal. Handling device loss ```typescript const device = await adapter.requestDevice(); device.lost.then((info) => { console.error(`Device lost: ${info.message}`); if (info.reason !== "destroyed") { initializeWebGPU(); // Attempt recovery } }); device.addEventListener("uncapturederror", (event) => { console.error("Uncaptured WebGPU error:", event.error); }); ``` Always Handle Device Loss Set up `device.lost` and error handlers immediately after device creation. Without these handlers, your application will fail silently when the GPU becomes unavailable. ## GPUQueue: Command Execution [Section titled “GPUQueue: Command Execution”](#gpuqueue-command-execution) The GPUQueue controls submission and execution of GPU commands. Each device has a default queue accessible via `device.queue`. ### Submitting Commands [Section titled “Submitting Commands”](#submitting-commands) Basic command submission ```typescript const commandEncoder = device.createCommandEncoder(); // ... encode commands ... const commandBuffer = commandEncoder.finish(); device.queue.submit([commandBuffer]); ``` Multiple command buffers in a single submit execute in sequence. ### Direct Data Writes [Section titled “Direct Data Writes”](#direct-data-writes) For small to medium updates, use direct write methods: Writing data to GPU resources ```typescript // Write to buffer const uniformData = new Float32Array([1.0, 0.0, 0.0, 1.0]); device.queue.writeBuffer(uniformBuffer, 0, uniformData); // Write to texture device.queue.writeTexture( { texture: gpuTexture }, imageData, { bytesPerRow: 256 * 4 }, { width: 256, height: 256 } ); ``` ### Synchronization [Section titled “Synchronization”](#synchronization) Commands execute asynchronously. Use `onSubmittedWorkDone()` when you need to wait: Waiting for GPU completion ```typescript await device.queue.onSubmittedWorkDone(); console.log("All GPU work completed"); ``` ## Initialization Flow [Section titled “Initialization Flow”](#initialization-flow) A complete, production-ready initialization: Complete WebGPU initialization ```typescript async function initializeWebGPU(): Promise<{ adapter: GPUAdapter; device: GPUDevice; format: GPUTextureFormat; }> { if (!navigator.gpu) { throw new Error("WebGPU not supported"); } const adapter = await navigator.gpu.requestAdapter({ powerPreference: "high-performance", }); if (!adapter) { throw new Error("No WebGPU adapter found"); } const requiredFeatures: GPUFeatureName[] = []; if (adapter.features.has("texture-compression-bc")) { requiredFeatures.push("texture-compression-bc"); } const device = await adapter.requestDevice({ requiredFeatures, requiredLimits: { maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize, }, }); device.lost.then((info) => { console.error(`Device lost: ${info.message}`); if (info.reason !== "destroyed") { initializeWebGPU(); } }); device.addEventListener("uncapturederror", (event) => { console.error("Uncaptured error:", event.error); }); const format = navigator.gpu.getPreferredCanvasFormat(); return { adapter, device, format }; } ``` ## Stateless Pipeline Architecture [Section titled “Stateless Pipeline Architecture”](#stateless-pipeline-architecture) WebGPU uses an explicit, immutable pipeline object model. Unlike WebGL’s state machine where you configure global state incrementally, WebGPU pipelines encapsulate complete GPU state at creation time. Creating and using a render pipeline ```typescript const pipeline = device.createRenderPipeline({ layout: pipelineLayout, vertex: { module: shaderModule, entryPoint: "vertexMain", buffers: [vertexBufferLayout], }, fragment: { module: shaderModule, entryPoint: "fragmentMain", targets: [{ format: "bgra8unorm" }], }, primitive: { topology: "triangle-list" }, }); // In render pass passEncoder.setPipeline(pipeline); passEncoder.setVertexBuffer(0, vertexBuffer); passEncoder.setBindGroup(0, bindGroup); passEncoder.drawIndexed(36); ``` ## Features and Limits [Section titled “Features and Limits”](#features-and-limits) ### Features [Section titled “Features”](#features) Optional capabilities checked via `adapter.features`: Checking optional features ```typescript const featureChecks = { textureCompression: { bc: adapter.features.has("texture-compression-bc"), etc2: adapter.features.has("texture-compression-etc2"), astc: adapter.features.has("texture-compression-astc"), }, shaderFeatures: { float16: adapter.features.has("shader-f16"), }, }; ``` Requesting available features ```typescript async function createDeviceWithFeatures(adapter: GPUAdapter) { const desired: GPUFeatureName[] = ["texture-compression-bc", "shader-f16"]; const available = desired.filter((f) => adapter.features.has(f)); return adapter.requestDevice({ requiredFeatures: available, }); } ``` ### Limits [Section titled “Limits”](#limits) Numeric constraints queried via `adapter.limits`: Querying device limits ```typescript const limits = adapter.limits; console.log({ maxTextureDimension2D: limits.maxTextureDimension2D, maxBufferSize: limits.maxBufferSize, maxBindGroups: limits.maxBindGroups, maxComputeWorkgroupSizeX: limits.maxComputeWorkgroupSizeX, }); ``` Requesting higher limits ```typescript const requestedLimit = 1024 * 1024 * 1024; const actualLimit = Math.min(requestedLimit, adapter.limits.maxStorageBufferBindingSize); const device = await adapter.requestDevice({ requiredLimits: { maxStorageBufferBindingSize: actualLimit }, }); ``` ## Resource Lifecycle [Section titled “Resource Lifecycle”](#resource-lifecycle) ### Creation [Section titled “Creation”](#creation) Resources are created through device methods with descriptor objects: Creating buffers and textures ```typescript const vertexBuffer = device.createBuffer({ size: 1024, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, mappedAtCreation: false, }); const texture = device.createTexture({ size: { width: 512, height: 512 }, format: "rgba8unorm", usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST, }); ``` ### Usage Flags [Section titled “Usage Flags”](#usage-flags) The `usage` parameter declares how resources will be used. WebGPU validates actual usage matches declared usage. Combine flags with bitwise OR: `GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST` ### Destruction [Section titled “Destruction”](#destruction) Explicitly destroy large resources when done: Resource cleanup ```typescript buffer.destroy(); texture.destroy(); ``` Memory Management For loops creating many resources, explicit destruction prevents GPU memory accumulation. Always destroy resources you no longer need. ### Error Scopes [Section titled “Error Scopes”](#error-scopes) Use error scopes for expected failure points: Catching creation errors ```typescript device.pushErrorScope("validation"); const buffer = device.createBuffer({ /* potentially invalid */ }); const error = await device.popErrorScope(); if (error) { console.warn("Buffer creation failed:", error.message); } ``` ## GPU Process Architecture [Section titled “GPU Process Architecture”](#gpu-process-architecture) WebGPU runs in a dedicated GPU process separate from the content process where JavaScript executes.