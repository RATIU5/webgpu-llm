<SYSTEM>React Integration: WebGPU patterns for React web and React Native applications</SYSTEM>

# React Integration

## Overview [Section titled “Overview”](#overview) WebGPU integrates with React through careful lifecycle management. This guide covers patterns for React web applications and React Native with `react-native-wgpu`. ## React Web Patterns [Section titled “React Web Patterns”](#react-web-patterns) ### useWebGPU Hook [Section titled “useWebGPU Hook”](#usewebgpu-hook) useWebGPU.ts ```typescript import { useEffect, useRef, useState } from "react"; interface WebGPUContext { device: GPUDevice; context: GPUCanvasContext; format: GPUTextureFormat; } export function useWebGPU(canvasRef: React.RefObject<HTMLCanvasElement>) { const [gpu, setGpu] = useState<WebGPUContext | null>(null); const [error, setError] = useState<string | null>(null); useEffect(() => { let destroyed = false; async function init() { if (!navigator.gpu) { setError("WebGPU not supported"); return; } const adapter = await navigator.gpu.requestAdapter(); if (!adapter) { setError("No GPU adapter found"); return; } const device = await adapter.requestDevice(); if (destroyed) { device.destroy(); return; } const canvas = canvasRef.current; if (!canvas) return; const context = canvas.getContext("webgpu"); if (!context) { setError("Failed to get WebGPU context"); return; } const format = navigator.gpu.getPreferredCanvasFormat(); context.configure({ device, format }); setGpu({ device, context, format }); } init(); return () => { destroyed = true; gpu?.device.destroy(); }; }, [canvasRef]); return { gpu, error }; } ``` ### Canvas Component [Section titled “Canvas Component”](#canvas-component) WebGPUCanvas.tsx ```tsx import { useRef, useEffect } from "react"; import { useWebGPU } from "./useWebGPU"; interface Props { onReady: (gpu: WebGPUContext) => void; onFrame?: (gpu: WebGPUContext, time: number) => void; } export function WebGPUCanvas({ onReady, onFrame }: Props) { const canvasRef = useRef<HTMLCanvasElement>(null); const { gpu, error } = useWebGPU(canvasRef); const frameRef = useRef<number>(); useEffect(() => { if (!gpu) return; onReady(gpu); if (onFrame) { function loop(time: number) { onFrame!(gpu!, time); frameRef.current = requestAnimationFrame(loop); } frameRef.current = requestAnimationFrame(loop); return () => { if (frameRef.current) cancelAnimationFrame(frameRef.current); }; } }, [gpu, onReady, onFrame]); if (error) return <div>Error: {error}</div>; return <canvas ref={canvasRef} width={800} height={600} />; } ``` ### TypeGPU with React [Section titled “TypeGPU with React”](#typegpu-with-react) TypeGPU React component ```tsx import { useEffect, useRef, useState } from "react"; import tgpu, { type TgpuRoot } from "typegpu"; import * as d from "typegpu/data"; export function ParticleSystem() { const canvasRef = useRef<HTMLCanvasElement>(null); const [root, setRoot] = useState<TgpuRoot | null>(null); useEffect(() => { let tgpuRoot: TgpuRoot | null = null; async function init() { tgpuRoot = await tgpu.init({ canvas: canvasRef.current!, }); setRoot(tgpuRoot); } init(); return () => { tgpuRoot?.destroy(); }; }, []); useEffect(() => { if (!root) return; // Create GPU resources const particles = root .createBuffer(d.arrayOf(d.vec4f, 1000)) .$usage("storage"); // Setup render loop... }, [root]); return <canvas ref={canvasRef} width={800} height={600} />; } ``` ### Resource Management [Section titled “Resource Management”](#resource-management) Cleanup is Critical GPU resources must be explicitly destroyed. Failing to cleanup causes memory leaks: ```tsx useEffect(() => { const buffer = device.createBuffer({ /* ... */ }); const texture = device.createTexture({ /* ... */ }); return () => { buffer.destroy(); texture.destroy(); }; }, [device]); ``` ### State Management [Section titled “State Management”](#state-management) GPU state with React state ```tsx function useGPUBuffer<T>(root: TgpuRoot, schema: TgpuDataType<T>) { const [data, setData] = useState<T | null>(null); const bufferRef = useRef<TgpuBuffer<T> | null>(null); useEffect(() => { bufferRef.current = root .createBuffer(schema) .$usage("storage", "uniform"); return () => { bufferRef.current?.destroy(); }; }, [root, schema]); const write = useCallback((newData: T) => { bufferRef.current?.write(newData); setData(newData); }, []); return { buffer: bufferRef.current, data, write }; } ``` ## React Native [Section titled “React Native”](#react-native) ### Requirements [Section titled “Requirements”](#requirements) * React Native 0.81+ * New Architecture enabled * `react-native-wgpu` package ### Setup [Section titled “Setup”](#setup) ```bash npm install react-native-wgpu typegpu npm install -D @webgpu/types ``` tsconfig.json ```json { "compilerOptions": { "types": ["@webgpu/types"] } } ``` babel.config.js (for TGSL) ```javascript module.exports = { plugins: ["unplugin-typegpu/babel"], }; ``` Expo Users React Native WebGPU is not supported by Expo Go. Run `expo prebuild` and build the native app. ### Basic Example [Section titled “Basic Example”](#basic-example) React Native WebGPU ```tsx import { Canvas, useDevice, useGPUContext } from "react-native-wgpu"; import tgpu from "typegpu"; import * as d from "typegpu/data"; function Triangle() { const device = useDevice(); const context = useGPUContext(); useEffect(() => { if (!device || !context) return; const format = navigator.gpu.getPreferredCanvasFormat(); context.configure({ device, format }); // Create shaders and pipeline const vertexFn = tgpu.vertexFn({ idx: d.builtin.vertexIndex, }, d.vec4f).does`(input) -> vec4f { const positions = array<vec2f, 3>( vec2f(0.0, 0.5), vec2f(-0.5, -0.5), vec2f(0.5, -0.5) ); return vec4f(positions[input.idx], 0.0, 1.0); }`; const fragmentFn = tgpu.fragmentFn({}, d.vec4f) .does`() -> @location(0) vec4f { return vec4f(1.0, 0.5, 0.0, 1.0); }`; // Build pipeline and render... }, [device, context]); return <Canvas style={{ flex: 1 }} />; } ``` ### Worklets Integration [Section titled “Worklets Integration”](#worklets-integration) For smooth animations, use Reanimated worklets: WebGPU Worklets ```tsx import { useSharedContext } from "react-native-webgpu-worklets"; function AnimatedScene() { const sharedContext = useSharedContext(); // GPU work runs on UI thread via worklets const renderWorklet = useCallback(() => { "worklet"; const { device, context } = sharedContext.value; // Render frame... }, [sharedContext]); return <Canvas onFrame={renderWorklet} />; } ``` ## Performance Tips [Section titled “Performance Tips”](#performance-tips) ### Minimize Re-renders [Section titled “Minimize Re-renders”](#minimize-re-renders) Memoize GPU-dependent components ```tsx const ParticleRenderer = memo(function ParticleRenderer({ particleBuffer, }: { particleBuffer: GPUBuffer; }) { // Only re-renders when buffer reference changes }); ``` ### Batch State Updates [Section titled “Batch State Updates”](#batch-state-updates) Avoid per-frame state updates ```tsx // Bad: causes re-render every frame const [frameCount, setFrameCount] = useState(0); function render() { setFrameCount(c => c + 1); // Don't do this } // Good: use refs for frame-local data const frameCountRef = useRef(0); function render() { frameCountRef.current++; // No re-render } ``` ### Stable References [Section titled “Stable References”](#stable-references) Stable callback references ```tsx const renderFrame = useCallback((time: number) => { // Render logic }, []); // Empty deps = stable reference useEffect(() => { const id = requestAnimationFrame(renderFrame); return () => cancelAnimationFrame(id); }, [renderFrame]); ``` ## Common Patterns [Section titled “Common Patterns”](#common-patterns) ### Resize Handling [Section titled “Resize Handling”](#resize-handling) Handle canvas resize ```tsx function useCanvasSize(canvasRef: React.RefObject<HTMLCanvasElement>) { const [size, setSize] = useState({ width: 0, height: 0 }); useEffect(() => { const observer = new ResizeObserver(([entry]) => { const { width, height } = entry.contentRect; setSize({ width, height }); }); if (canvasRef.current) { observer.observe(canvasRef.current); } return () => observer.disconnect(); }, [canvasRef]); return size; } ``` ### Error Boundaries [Section titled “Error Boundaries”](#error-boundaries) GPU error boundary ```tsx class GPUErrorBoundary extends React.Component< { children: React.ReactNode; fallback: React.ReactNode }, { hasError: boolean } > { state = { hasError: false }; static getDerivedStateFromError() { return { hasError: true }; } render() { if (this.state.hasError) { return this.props.fallback; } return this.props.children; } } ``` ## Resources [Section titled “Resources”](#resources)