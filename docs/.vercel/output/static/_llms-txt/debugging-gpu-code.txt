<SYSTEM>Debugging GPU Code: GPU console.log, validation layers, and debugging techniques</SYSTEM>

# Debugging GPU Code

## Overview [Section titled “Overview”](#overview) GPU debugging differs fundamentally from CPU debugging due to massive parallelism, separate execution contexts, and limited introspection capabilities. This guide covers validation layers, TypeGPU debugging features, visual debugging techniques, and browser developer tools. ## Validation Layers [Section titled “Validation Layers”](#validation-layers) WebGPU validates all operations and reports detailed errors through the browser console: Error scope pattern ```typescript device.pushErrorScope("validation"); const buffer = device.createBuffer({ size: 256, usage: GPUBufferUsage.UNIFORM, // Missing COPY_DST }); device.queue.writeBuffer(buffer, 0, data); // Will fail const error = await device.popErrorScope(); if (error) { console.error("Validation error:", error.message); } ``` ### Common Validation Errors [Section titled “Common Validation Errors”](#common-validation-errors) | Error | Cause | Fix | | ------------------- | ---------------------------------------- | ------------------------------------------- | | Missing usage flag | Buffer created without required usage | Add `GPUBufferUsage.COPY_DST` for writes | | Binding mismatch | Shader bindings don’t match bind group | Ensure `@group`/`@binding` match JavaScript | | Format incompatible | Texture view format differs from texture | Use matching formats | | Size mismatch | Buffer too small for shader expectations | Check minimum binding sizes | ## TypeGPU Console.log [Section titled “TypeGPU Console.log”](#typegpu-consolelog) TypeGPU enables `console.log` directly in GPU shaders: GPU console.log ```typescript import tgpu from "typegpu"; import * as d from "typegpu/data"; const processData = tgpu.fn([d.f32], d.f32).does((input) => { console.log("Processing input:", input); const result = input * 2.0; console.log("Computed result:", result); return result; }); ``` Console.log Limitations * **Performance overhead**: Buffer writes consume GPU time * **Fixed buffer size**: Excessive logging truncates output * **Deferred output**: Messages appear after execution completes * **Parallel flood**: Millions of invocations can overwhelm the log Use conditional logging to limit output volume: ```typescript if (pixelIndex < 10) { console.log("Processing pixel:", pixelIndex); } ``` ## CPU Simulation [Section titled “CPU Simulation”](#cpu-simulation) TypeGPU’s `tgpu.simulate()` runs shader code on CPU with full debugging: CPU simulation with debugging ```typescript import tgpu from "typegpu"; import * as d from "typegpu/data"; const computeGradient = tgpu.fn([d.f32, d.f32], d.f32).does((x, y) => { const dx = x * 2.0; const dy = y * 3.0; return Math.sqrt(dx * dx + dy * dy); }); // Simulate on CPU - set breakpoints, inspect variables const result = tgpu["~unstable"].simulate(() => { return computeGradient(5.0, 3.0); }); console.log("Simulated result:", result); ``` ## Visual Debugging [Section titled “Visual Debugging”](#visual-debugging) Encode shader values as colors to visualize program state: Visualize normals as RGB ```wgsl @fragment fn debugNormals(@location(0) normal: vec3<f32>) -> @location(0) vec4<f32> { // Transform [-1,1] to [0,1] range let r = normal.x * 0.5 + 0.5; let g = normal.y * 0.5 + 0.5; let b = normal.z * 0.5 + 0.5; return vec4<f32>(r, g, b, 1.0); } ``` ### Common Visualization Techniques [Section titled “Common Visualization Techniques”](#common-visualization-techniques) ## Shader Compilation Errors [Section titled “Shader Compilation Errors”](#shader-compilation-errors) ### Error Types [Section titled “Error Types”](#error-types) | Type | Example | Fix | | -------- | ---------------------------------------- | --------------------------- | | Parser | Missing semicolon, invalid token | Check WGSL syntax | | Type | Returning `f32` from `i32` function | Use explicit casts | | Semantic | Duplicate binding, invalid address space | Check resource declarations | ### Debugging Strategy [Section titled “Debugging Strategy”](#debugging-strategy) 1. **Isolate**: Comment out code sections until error disappears 2. **Minimize**: Create smallest shader that reproduces the error 3. **Verify types**: Add explicit type annotations 4. **Check bindings**: Ensure `@group`/`@binding` are unique and match JavaScript ## Runtime Errors [Section titled “Runtime Errors”](#runtime-errors) ### Device Lost [Section titled “Device Lost”](#device-lost) Handle device loss ```typescript device.lost.then((info) => { console.error("Device lost:", info.reason, info.message); if (info.reason !== "destroyed") { // Attempt recovery reinitializeWebGPU(); } }); ``` **Common causes**: Driver crash, GPU timeout, resource exhaustion ### Out of Memory [Section titled “Out of Memory”](#out-of-memory) Handle OOM errors ```typescript device.pushErrorScope("out-of-memory"); const largeTexture = device.createTexture({ size: { width: 8192, height: 8192 }, format: "rgba16float", usage: GPUTextureUsage.STORAGE_BINDING, }); const error = await device.popErrorScope(); if (error) { // Use smaller texture createFallbackTexture(); } ``` ## Browser Developer Tools [Section titled “Browser Developer Tools”](#browser-developer-tools) ### WebGPU Inspector [Section titled “WebGPU Inspector”](#webgpu-inspector) Available for Chrome, Firefox, and Safari: * **Inspection Mode**: View live GPU objects * **Capture Mode**: Record GPU commands per frame * **Shader Editing**: Edit and reload shaders live * **Performance**: Plot frame times and object counts ### Platform-Specific Tools [Section titled “Platform-Specific Tools”](#platform-specific-tools) | Browser | Tools | | ------- | ---------------------------------------- | | Chrome | DevTools Performance tab, `chrome://gpu` | | Firefox | Graphics inspector, about:support | | Safari | Web Inspector, Metal frame capture | ## Debugging Workflow [Section titled “Debugging Workflow”](#debugging-workflow) Debug vs Release pattern ```typescript const DEBUG = import.meta.env.DEV; if (DEBUG) { device.pushErrorScope("validation"); // Enable detailed logging } // Create resources with labels const buffer = device.createBuffer({ label: "Particle Position Buffer", // Shows in error messages size: particleCount * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, }); ``` ### Incremental Development [Section titled “Incremental Development”](#incremental-development) 1. Start with minimal working shader 2. Add one feature at a time 3. Test after each addition 4. Use simulation for algorithm verification 5. Validate on GPU with visual debugging 6. Optimize only after confirming correctness Asynchronous Error Handling GPU errors may appear later than the causative code. Always use error scopes: ```typescript device.pushErrorScope("validation"); // ... operations that might fail ... const error = await device.popErrorScope(); ``` ## Resources [Section titled “Resources”](#resources)