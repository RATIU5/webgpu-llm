<SYSTEM>Bind Groups and Layouts: Connecting resources to shaders with type-safe bindings</SYSTEM>

# Bind Groups and Layouts

## Overview [Section titled “Overview”](#overview) Bind groups and layouts form the cornerstone of WebGPU’s resource binding model, providing a structured way to connect GPU resources to shader programs. ## Key Concepts [Section titled “Key Concepts”](#key-concepts) ### Bind Group [Section titled “Bind Group”](#bind-group) A collection of GPU resources (buffers, textures, samplers) bundled as a single unit: Conceptual bind group ```javascript // Instead of binding resources individually: bindResource(0, uniformBuffer); bindResource(1, storageBuffer); bindResource(2, texture); // Bind them together: passEncoder.setBindGroup(0, myBindGroup); ``` ### Bind Group Layout [Section titled “Bind Group Layout”](#bind-group-layout) Defines the structure bind groups must follow: * Number of bindings * Resource type at each binding (buffer, texture, sampler) * Shader stages that can access each resource * Buffer types, texture formats, access modes ### WGSL Binding Indices [Section titled “WGSL Binding Indices”](#wgsl-binding-indices) Resources are referenced using two attributes: WGSL resource declarations ```wgsl @group(0) @binding(0) var<uniform> camera: Camera; @group(0) @binding(1) var<storage, read> positions: array<vec3f>; @group(1) @binding(0) var diffuseTexture: texture_2d<f32>; @group(1) @binding(1) var textureSampler: sampler; ``` ### Shader Stage Visibility [Section titled “Shader Stage Visibility”](#shader-stage-visibility) | Stage | Flag | Use Case | | -------- | ------------------------- | ---------------------------- | | Vertex | `GPUShaderStage.VERTEX` | Transformations, vertex data | | Fragment | `GPUShaderStage.FRAGMENT` | Textures, lighting | | Compute | `GPUShaderStage.COMPUTE` | General computation | Combine with bitwise OR: `GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT` ## Creating Bind Group Layouts [Section titled “Creating Bind Group Layouts”](#creating-bind-group-layouts) Compute bind group layout ```javascript const bindGroupLayout = device.createBindGroupLayout({ label: "Compute Bind Group Layout", entries: [ { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform", minBindingSize: 16, }, }, { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage", }, }, { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage", // Read-write }, }, ], }); ``` ### Entry Types [Section titled “Entry Types”](#entry-types) ## Creating Bind Groups [Section titled “Creating Bind Groups”](#creating-bind-groups) Create bind group from layout ```javascript const bindGroup = device.createBindGroup({ label: "Compute Bind Group", layout: bindGroupLayout, entries: [ { binding: 0, resource: { buffer: uniformBuffer, offset: 0, size: 16, }, }, { binding: 1, resource: { buffer: inputBuffer }, }, { binding: 2, resource: { buffer: outputBuffer }, }, ], }); ``` For textures and samplers: Texture and sampler bind group ```javascript const renderBindGroup = device.createBindGroup({ label: "Render Bind Group", layout: renderBindGroupLayout, entries: [ { binding: 0, resource: sampler, // GPUSampler object }, { binding: 1, resource: texture.createView(), // GPUTextureView }, ], }); ``` Validation Requirements Entries must exactly match the layout: * Same binding numbers * Correct resource types * All bindings provided ## Pipeline Layouts [Section titled “Pipeline Layouts”](#pipeline-layouts) Combines multiple bind group layouts for a complete pipeline interface: Create pipeline layout ```javascript const pipelineLayout = device.createPipelineLayout({ label: "Main Pipeline Layout", bindGroupLayouts: [ bindGroupLayout0, // @group(0) bindGroupLayout1, // @group(1) bindGroupLayout2, // @group(2) ], }); const computePipeline = device.createComputePipeline({ label: "Compute Pipeline", layout: pipelineLayout, compute: { module: shaderModule, entryPoint: "main", }, }); ``` ### Automatic Layout [Section titled “Automatic Layout”](#automatic-layout) Use `layout: "auto"` to infer layout from shader: Auto layout pipeline ```javascript const pipeline = device.createComputePipeline({ layout: "auto", compute: { module: shaderModule, entryPoint: "main", }, }); // Retrieve inferred layout for bind group creation const bindGroupLayout = pipeline.getBindGroupLayout(0); ``` ## TypeGPU Bind Groups [Section titled “TypeGPU Bind Groups”](#typegpu-bind-groups) TypeGPU provides type-safe abstractions, eliminating manual index management. ### Type-safe Layouts [Section titled “Type-safe Layouts”](#type-safe-layouts) TypeGPU bind group layout ```typescript import { tgpu, d } from "typegpu"; const UniformsSchema = d.struct({ viewProjection: d.mat4x4f, time: d.f32, lightDirection: d.vec3f, }); const sceneLayout = tgpu.bindGroupLayout({ uniforms: { uniform: UniformsSchema }, instanceData: { storage: d.arrayOf(d.mat4x4f) }, }); ``` ### Resource Types in TypeGPU [Section titled “Resource Types in TypeGPU”](#resource-types-in-typegpu) TypeGPU resource type syntax ```typescript const layout = tgpu.bindGroupLayout({ // Uniform buffer (read-only) uniforms: { uniform: d.struct({ value: d.f32 }) }, // Storage buffer (read-only by default) readData: { storage: d.arrayOf(d.f32) }, // Mutable storage buffer writeData: { storage: d.f32, access: "mutable" }, // Filtering sampler linearSampler: { sampler: "filtering" }, // Texture diffuseTexture: { texture: d.tex2d<"f32"> }, // Storage texture outputTexture: { storageTexture: d.storageTex2d<"rgba8unorm"> }, }); ``` ### Creating TypeGPU Bind Groups [Section titled “Creating TypeGPU Bind Groups”](#creating-typegpu-bind-groups) Type-safe bind group creation ```typescript const uniformBuffer = root.createBuffer(UniformsSchema, { viewProjection: mat4.identity(), time: 0, lightDirection: vec3(0, -1, 0), }); const storageBuffer = root.createBuffer( d.arrayOf(d.f32), new Float32Array(1000) ); const bindGroup = root.createBindGroup(sceneLayout, { uniforms: uniformBuffer, instanceData: storageBuffer, }); ``` ## Dynamic Binding [Section titled “Dynamic Binding”](#dynamic-binding) Dynamic offsets allow using different buffer sections without creating multiple bind groups. ### Enable Dynamic Offsets [Section titled “Enable Dynamic Offsets”](#enable-dynamic-offsets) Layout with dynamic offset ```javascript const layout = device.createBindGroupLayout({ entries: [ { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: "uniform", hasDynamicOffset: true, minBindingSize: 256, }, }, ], }); ``` ### Use Dynamic Offsets [Section titled “Use Dynamic Offsets”](#use-dynamic-offsets) Render loop with dynamic offsets ```javascript const passEncoder = commandEncoder.beginRenderPass(/* ... */); passEncoder.setPipeline(pipeline); for (let i = 0; i < objectCount; i++) { const offset = i * 256; // Must be 256-byte aligned passEncoder.setBindGroup(0, bindGroup, [offset]); passEncoder.draw(vertexCount, 1, 0, 0); } passEncoder.end(); ``` Alignment Requirements * **Uniform buffers**: 256-byte alignment * **Storage buffers**: 32-byte alignment ```javascript // Calculate aligned offset const alignedOffset = Math.ceil(dataSize / 256) * 256; ``` ## Resource Visibility [Section titled “Resource Visibility”](#resource-visibility) ### Visibility Patterns [Section titled “Visibility Patterns”](#visibility-patterns) | Pattern | Visibility | Use Case | | --------------- | -------------------- | ------------------------------ | | Per-frame data | `VERTEX \| FRAGMENT` | Camera, time, global settings | | Transformations | `VERTEX` | Model matrices, bone data | | Materials | `FRAGMENT` | Textures, lighting parameters | | Compute-only | `COMPUTE` | Storage buffers, dispatch data | ## Efficient Binding [Section titled “Efficient Binding”](#efficient-binding) ### Group by Update Frequency [Section titled “Group by Update Frequency”](#group-by-update-frequency) Organized pipeline layout ```javascript // Group 0: Per-frame (updated once per frame) const frameLayout = device.createBindGroupLayout({ entries: [ { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }, // Camera, time ], }); // Group 1: Per-material (updated when material changes) const materialLayout = device.createBindGroupLayout({ entries: [ { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } }, { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } }, ], }); // Group 2: Per-object (updated every draw call) const objectLayout = device.createBindGroupLayout({ entries: [ { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: "uniform", hasDynamicOffset: true } }, ], }); ``` ### Efficient Render Loop [Section titled “Efficient Render Loop”](#efficient-render-loop) Minimizing bind group switches ```javascript const frameBindGroup = /* created once per frame */; passEncoder.setBindGroup(0, frameBindGroup); for (const material of materials) { passEncoder.setBindGroup(1, material.bindGroup); for (const object of objectsWithMaterial(material)) { // Use dynamic offset instead of new bind group passEncoder.setBindGroup(2, objectBindGroup, [object.uniformOffset]); passEncoder.draw(/* ... */); } } ``` ### Share Layouts Between Pipelines [Section titled “Share Layouts Between Pipelines”](#share-layouts-between-pipelines) Reusable bind group layout ```javascript const sharedLayout = device.createBindGroupLayout({ /* ... */ }); const pipeline1 = device.createRenderPipeline({ layout: device.createPipelineLayout({ bindGroupLayouts: [sharedLayout], }), // ... }); const pipeline2 = device.createRenderPipeline({ layout: device.createPipelineLayout({ bindGroupLayouts: [sharedLayout], // Same layout }), // ... }); // One bind group works with both pipelines const bindGroup = device.createBindGroup({ layout: sharedLayout, entries: [/* ... */] }); ``` ## Complete Example [Section titled “Complete Example”](#complete-example) Full compute pipeline with bind groups ```javascript // WGSL compute shader const shaderCode = ` struct Params { multiplier: f32, offset: f32 } @group(0) @binding(0) var<uniform> params: Params; @group(0) @binding(1) var<storage, read> input: array<f32>; @group(0) @binding(2) var<storage, read_write> output: array<f32>; @compute @workgroup_size(64) fn main(@builtin(global_invocation_id) gid: vec3u) { let index = gid.x; if (index < arrayLength(&input)) { output[index] = input[index] * params.multiplier + params.offset; } } `; const shaderModule = device.createShaderModule({ code: shaderCode }); // Create bind group layout const bindGroupLayout = device.createBindGroupLayout({ entries: [ { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } }, { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } }, { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } }, ], }); // Create pipeline const pipeline = device.createComputePipeline({ layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout], }), compute: { module: shaderModule, entryPoint: "main", }, }); // Create buffers const paramsBuffer = device.createBuffer({ size: 8, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, }); const inputData = new Float32Array(1024); for (let i = 0; i < inputData.length; i++) inputData[i] = i; const inputBuffer = device.createBuffer({ size: inputData.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, }); const outputBuffer = device.createBuffer({ size: inputData.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC, }); // Write data device.queue.writeBuffer(paramsBuffer, 0, new Float32Array([2.0, 1.0])); device.queue.writeBuffer(inputBuffer, 0, inputData); // Create bind group const bindGroup = device.createBindGroup({ layout: bindGroupLayout, entries: [ { binding: 0, resource: { buffer: paramsBuffer } }, { binding: 1, resource: { buffer: inputBuffer } }, { binding: 2, resource: { buffer: outputBuffer } }, ], }); // Execute const commandEncoder = device.createCommandEncoder(); const passEncoder = commandEncoder.beginComputePass(); passEncoder.setPipeline(pipeline); passEncoder.setBindGroup(0, bindGroup); passEncoder.dispatchWorkgroups(Math.ceil(inputData.length / 64)); passEncoder.end(); device.queue.submit([commandEncoder.finish()]); ``` ## Resources [Section titled “Resources”](#resources)