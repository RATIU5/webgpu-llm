<SYSTEM>TGSL Functions: Writing shader functions in TypeScript with TypeGPU's TGSL</SYSTEM>

# TGSL Functions

## Overview [Section titled “Overview”](#overview) TGSL (TypeGPU Shading Language) enables writing GPU shader code in TypeScript rather than WGSL. Functions written in TGSL execute on both CPU and GPU, providing type safety, IDE support, and code reusability. ## The ‘use gpu’ Directive [Section titled “The ‘use gpu’ Directive”](#the-use-gpu-directive) Basic TGSL function ```typescript import tgpu from "typegpu"; import * as d from "typegpu/data"; const addVectors = tgpu.fn([d.vec3f, d.vec3f], d.vec3f).does((a, b) => { "use gpu"; // First statement in function body return a.add(b); }); ``` ### Dual-Mode Execution [Section titled “Dual-Mode Execution”](#dual-mode-execution) Functions with `'use gpu'` run on both CPU (for testing) and GPU (as shaders): Test on CPU, run on GPU ```typescript const clampValue = tgpu.fn([d.f32, d.f32, d.f32], d.f32).does((value, min, max) => { "use gpu"; if (value < min) return min; if (value > max) return max; return value; }); // Test on CPU console.assert(clampValue(5, 0, 10) === 5); console.assert(clampValue(-5, 0, 10) === 0); // Use in GPU shader const shader = tgpu.fn([buffer]).does(() => { "use gpu"; buffer.value[idx] = clampValue(buffer.value[idx], 0.0, 1.0); }); ``` ### Supported JavaScript Features [Section titled “Supported JavaScript Features”](#supported-javascript-features) Build Plugin Required TGSL requires `unplugin-typegpu` to transpile to WGSL. Without the plugin, functions run only on CPU. ## Defining Functions with tgpu.fn() [Section titled “Defining Functions with tgpu.fn()”](#defining-functions-with-tgpufn) ### Basic Functions [Section titled “Basic Functions”](#basic-functions) Function definitions ```typescript // Scalar function const add = tgpu.fn([d.f32, d.f32], d.f32).does((a, b) => { "use gpu"; return a + b; }); // Vector function const distance = tgpu.fn([d.vec3f, d.vec3f], d.f32).does((a, b) => { "use gpu"; const delta = b.sub(a); return Math.sqrt(delta.dot(delta)); }); // Void return (omit return type) const updateParticle = tgpu.fn([particleBuffer, d.u32]).does((particles, index) => { "use gpu"; particles.value[index].position = particles.value[index].position.add(velocity); }); ``` ### Entry Points [Section titled “Entry Points”](#entry-points) ## Accessing GPU Resources [Section titled “Accessing GPU Resources”](#accessing-gpu-resources) ### The .value Property [Section titled “The .value Property”](#the-value-property) Objects with different CPU and GPU representations (buffers, slots) must be accessed via `.value` (or `$` alias): Resource access in TGSL ```typescript const particleBuffer = root.createBuffer(d.arrayOf(d.vec3f, 1000)).$usage("storage"); const deltaTime = root.createUniform(d.f32, 0.016); const updateParticles = tgpu.fn([particleBuffer, deltaTime]).does(() => { "use gpu"; const idx = builtin.globalInvocationId.x; // Use .value or $ to access GPU resources const position = particleBuffer.value[idx]; // or particleBuffer.$[idx] const dt = deltaTime.value; // or deltaTime.$ particleBuffer.value[idx] = position.add(d.vec3f(0, -9.8 * dt, 0)); }); ``` Why .value? TypeGPU buffer objects are JavaScript proxies with CPU APIs. The `.value` property signals “access the GPU representation.” ## Standard Library (typegpu/std) [Section titled “Standard Library (typegpu/std)”](#standard-library-typegpustd) Standard library functions ```typescript import { distance, length, normalize, dot, cross, clamp, mix, smoothstep } from "typegpu/std"; const lighting = tgpu.fn([d.vec3f, d.vec3f], d.vec3f).does((normal, lightDir) => { "use gpu"; const n = normalize(normal); const l = normalize(lightDir); const diffuse = clamp(dot(n, l), 0.0, 1.0); return d.vec3f(diffuse); }); ``` ## Vector and Matrix Operations [Section titled “Vector and Matrix Operations”](#vector-and-matrix-operations) ### Chained Methods (TypeGPU 0.7+) [Section titled “Chained Methods (TypeGPU 0.7+)”](#chained-methods-typegpu-07) Vector operations ```typescript const physics = tgpu.fn([d.vec3f, d.vec3f, d.f32], d.vec3f).does((pos, vel, dt) => { "use gpu"; const gravity = d.vec3f(0, -9.8, 0); const newVel = vel.add(gravity.mul(dt)); return pos.add(newVel.mul(dt)); }); ``` | Operation | Method | WGSL Equivalent | | ------------- | --------------- | --------------- | | Add | `a.add(b)` | `a + b` | | Subtract | `a.sub(b)` | `a - b` | | Multiply | `a.mul(b)` | `a * b` | | Divide | `a.div(b)` | `a / b` | | Length | `a.length()` | `length(a)` | | Normalize | `a.normalize()` | `normalize(a)` | | Dot product | `a.dot(b)` | `dot(a, b)` | | Cross product | `a.cross(b)` | `cross(a, b)` | ### Matrix Operations [Section titled “Matrix Operations”](#matrix-operations) Matrix multiplication ```typescript const transform = tgpu.fn([d.mat4x4f, d.vec3f], d.vec4f).does((mat, pos) => { "use gpu"; return mat.mul(d.vec4f(pos.x, pos.y, pos.z, 1.0)); }); ``` ## Mixing WGSL and TGSL [Section titled “Mixing WGSL and TGSL”](#mixing-wgsl-and-tgsl) ### Call WGSL from TGSL [Section titled “Call WGSL from TGSL”](#call-wgsl-from-tgsl) WGSL function called from TGSL ```typescript const complexOp = tgpu.fn([d.mat4x4f, d.mat4x4f], d.mat4x4f) .implement(/* wgsl */ ` fn complexOp(a: mat4x4f, b: mat4x4f) -> mat4x4f { return transpose(a * b); } `); const useWgsl = tgpu.fn([d.mat4x4f, d.mat4x4f], d.mat4x4f).does((a, b) => { "use gpu"; return complexOp(a, b); // Call WGSL function }); ``` ### Call TGSL from WGSL [Section titled “Call TGSL from WGSL”](#call-tgsl-from-wgsl) TGSL function used in WGSL ```typescript const clamp = tgpu.fn([d.f32, d.f32, d.f32], d.f32).does((val, min, max) => { "use gpu"; if (val < min) return min; if (val > max) return max; return val; }); const processValue = tgpu.fn([d.f32], d.f32) .implement(/* wgsl */ ` fn processValue(input: f32) -> f32 { return clamp(input * 2.0, 0.0, 10.0); } `) .$uses({ clamp }); ``` ## GPU Console.log [Section titled “GPU Console.log”](#gpu-consolelog) Debug with console.log ```typescript const debugShader = tgpu.computeFn([buffer]).does(() => { "use gpu"; const idx = builtin.globalInvocationId.x; if (idx < 5) { // Limit output console.log("Thread", idx, "value:", buffer.value[idx]); } buffer.value[idx] = buffer.value[idx] * 2; }).$workgroupSize(64); ``` Limitations * Buffer limit for logged values * Performance overhead—remove for production * Works with scalars and vectors ## Common Patterns [Section titled “Common Patterns”](#common-patterns) ### Function Composition [Section titled “Function Composition”](#function-composition) Reusable utilities ```typescript const saturate = tgpu.fn([d.f32], d.f32).does((x) => { "use gpu"; return clamp(x, 0, 1); }); const attenuate = tgpu.fn([d.f32, d.f32], d.f32).does((dist, radius) => { "use gpu"; const ratio = dist / radius; return saturate(1.0 - ratio * ratio); }); const pointLight = tgpu.fn([d.vec3f, d.vec3f, d.f32], d.f32).does((fragPos, lightPos, radius) => { "use gpu"; const dist = distance(fragPos, lightPos); return attenuate(dist, radius); }); ``` ### Shared CPU/GPU Logic [Section titled “Shared CPU/GPU Logic”](#shared-cpugpu-logic) Code reuse ```typescript const applyGravity = tgpu.fn([d.vec3f, d.f32], d.vec3f).does((velocity, dt) => { "use gpu"; return velocity.add(d.vec3f(0, -9.8, 0).mul(dt)); }); // CPU testing function simulateOnCPU(particles, dt) { for (const p of particles) { p.velocity = applyGravity(p.velocity, dt); } } // GPU shader const gpuUpdate = tgpu.computeFn([particleBuffer, deltaTime]).does(() => { "use gpu"; const idx = builtin.globalInvocationId.x; particleBuffer.value[idx].velocity = applyGravity( particleBuffer.value[idx].velocity, deltaTime.value ); }).$workgroupSize(64); ``` ## Common Pitfalls [Section titled “Common Pitfalls”](#common-pitfalls) Forgetting .value ```typescript // WRONG const value = buffer[0]; // CORRECT const value = buffer.value[0]; ``` Missing ‘use gpu’ ```typescript // WRONG - runs CPU only const shader = tgpu.fn([d.f32], d.f32).does((x) => { return x * 2; }); // CORRECT const shader = tgpu.fn([d.f32], d.f32).does((x) => { "use gpu"; return x * 2; }); ``` Value vs Reference Semantics In JavaScript (CPU), vectors are references. In WGSL (GPU), they’re values: ```typescript // CPU: b references same object as a const b = a; b[0] = 10; // Modifies a! // GPU: b is a copy const b = a; b[0] = 10; // a unchanged ``` ## Resources [Section titled “Resources”](#resources)