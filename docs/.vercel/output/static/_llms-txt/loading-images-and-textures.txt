<SYSTEM>Loading Images and Textures: Loading images, video frames, and compressed textures into WebGPU</SYSTEM>

# Loading Images and Textures

## Overview [Section titled “Overview”](#overview) WebGPU provides multiple methods for loading image data into textures. The approach depends on your source: files, canvas elements, video frames, or compressed formats. ## Loading from URLs [Section titled “Loading from URLs”](#loading-from-urls) ### Basic Image Loading [Section titled “Basic Image Loading”](#basic-image-loading) Load image from URL ```javascript async function loadTexture(device, url) { // 1. Fetch and decode const response = await fetch(url); const blob = await response.blob(); const imageBitmap = await createImageBitmap(blob); // 2. Create texture const texture = device.createTexture({ size: [imageBitmap.width, imageBitmap.height], format: "rgba8unorm", usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST, }); // 3. Upload to GPU device.queue.copyExternalImageToTexture( { source: imageBitmap }, { texture }, [imageBitmap.width, imageBitmap.height] ); return texture; } ``` ### createImageBitmap Options [Section titled “createImageBitmap Options”](#createimagebitmap-options) Control decode behavior ```javascript const imageBitmap = await createImageBitmap(blob, { // Prevent color space conversion (preserve raw values) colorSpaceConversion: "none", // Resize during decode (more efficient than GPU resize) resizeWidth: 512, resizeHeight: 512, resizeQuality: "high", // "pixelated" | "low" | "medium" | "high" // Pre-multiply alpha (matches WebGPU default) premultiplyAlpha: "premultiply", // "none" | "premultiply" | "default" }); ``` ## copyExternalImageToTexture [Section titled “copyExternalImageToTexture”](#copyexternalimagetotexture) ### Parameters [Section titled “Parameters”](#parameters) Full parameter options ```javascript device.queue.copyExternalImageToTexture( // Source { source: imageBitmap, // ImageBitmap, HTMLCanvasElement, HTMLVideoElement, etc. origin: [0, 0], // Optional: source region offset flipY: false, // Optional: flip vertically }, // Destination { texture: gpuTexture, origin: [0, 0, 0], // Optional: write location [x, y, layer] mipLevel: 0, // Optional: target mip level colorSpace: "srgb", // Optional: "srgb" | "display-p3" premultipliedAlpha: false, // Optional: premultiply RGB by alpha }, // Copy size [width, height] // Or { width, height, depthOrArrayLayers } ); ``` ### Valid Source Types [Section titled “Valid Source Types”](#valid-source-types) | Source | Notes | | ------------------- | ----------------------------------------------------- | | `ImageBitmap` | Preferred—async decode | | `HTMLCanvasElement` | Direct copy, no decode needed | | `OffscreenCanvas` | Worker-compatible | | `HTMLVideoElement` | Current frame (use `importExternalTexture` for video) | | `VideoFrame` | WebCodecs integration | | `ImageData` | From canvas `getImageData()` | Avoid HTMLImageElement Passing `HTMLImageElement` directly can cause synchronous decoding, blocking the main thread. Always use `createImageBitmap()` first. ### Handling Y-Axis Orientation [Section titled “Handling Y-Axis Orientation”](#handling-y-axis-orientation) WebGPU textures have origin at top-left. Some image formats store bottom-to-top: Flip image on upload ```javascript device.queue.copyExternalImageToTexture( { source: imageBitmap, flipY: true }, { texture }, [imageBitmap.width, imageBitmap.height] ); ``` ## Required Texture Usage Flags [Section titled “Required Texture Usage Flags”](#required-texture-usage-flags) Texture for sampling ```javascript const texture = device.createTexture({ size: [width, height], format: "rgba8unorm", usage: GPUTextureUsage.TEXTURE_BINDING | // Use in shaders GPUTextureUsage.COPY_DST, // Required for copyExternalImageToTexture }); ``` If generating mipmaps via render pass, add `RENDER_ATTACHMENT`: Texture with mipmap support ```javascript const mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1; const texture = device.createTexture({ size: [width, height], format: "rgba8unorm", mipLevelCount, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT, // For mipmap generation }); ``` ## Canvas Textures [Section titled “Canvas Textures”](#canvas-textures) Canvas elements can be copied directly without `createImageBitmap()`: Copy from canvas ```javascript const canvas = document.querySelector("canvas"); const ctx = canvas.getContext("2d"); // Draw something ctx.fillStyle = "red"; ctx.fillRect(0, 0, 100, 100); // Copy to texture const texture = device.createTexture({ size: [canvas.width, canvas.height], format: "rgba8unorm", usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST, }); device.queue.copyExternalImageToTexture( { source: canvas }, { texture }, [canvas.width, canvas.height] ); ``` ## Video Textures [Section titled “Video Textures”](#video-textures) ### External Textures (Recommended) [Section titled “External Textures (Recommended)”](#external-textures-recommended) For video playback, `importExternalTexture()` provides a zero-copy fast path: Video texture ```javascript const video = document.createElement("video"); video.src = "video.mp4"; video.loop = true; await video.play(); function frame() { // Create external texture each frame const externalTexture = device.importExternalTexture({ source: video }); // Use in render pass... // Must use immediately—destroyed at end of task requestAnimationFrame(frame); } ``` External Texture Lifetime External textures are automatically destroyed when JavaScript returns to the browser event loop. You must create and use them within the same callback: ```javascript // ✗ Wrong: texture destroyed before use const tex = device.importExternalTexture({ source: video }); await someAsyncOperation(); // Crossing await boundary renderWithTexture(tex); // Error: texture expired // ✓ Correct: create and use in same frame requestAnimationFrame(() => { const tex = device.importExternalTexture({ source: video }); renderWithTexture(tex); }); ``` ### WGSL for External Textures [Section titled “WGSL for External Textures”](#wgsl-for-external-textures) Sampling external texture ```wgsl @group(0) @binding(0) var externalTex: texture_external; @group(0) @binding(1) var samp: sampler; @fragment fn main(@location(0) uv: vec2f) -> @location(0) vec4f { return textureSampleBaseClampToEdge(externalTex, samp, uv); } ``` ### Video via copyExternalImageToTexture [Section titled “Video via copyExternalImageToTexture”](#video-via-copyexternalimagetotexture) For persistent video textures (slower but longer-lived): Copy video frame to regular texture ```javascript function frame() { if (video.readyState >= video.HAVE_CURRENT_DATA) { device.queue.copyExternalImageToTexture( { source: video }, { texture: videoTexture }, [video.videoWidth, video.videoHeight] ); } requestAnimationFrame(frame); } ``` ## Compressed Textures [Section titled “Compressed Textures”](#compressed-textures) Compressed textures reduce GPU memory and bandwidth. WebGPU supports three formats, but availability depends on hardware. ### Format Support [Section titled “Format Support”](#format-support) | Format | Desktop | Mobile | Feature Name | | ------------- | ------------- | -------------- | -------------------------- | | BC (DXT/S3TC) | ✓ Windows/Mac | ✗ | `texture-compression-bc` | | ETC2 | ✗ | ✓ iOS/Android | `texture-compression-etc2` | | ASTC | ✗ | ✓ Newer mobile | `texture-compression-astc` | ### Checking Feature Support [Section titled “Checking Feature Support”](#checking-feature-support) Query compression support ```javascript const adapter = await navigator.gpu.requestAdapter(); const hasBC = adapter.features.has("texture-compression-bc"); const hasETC2 = adapter.features.has("texture-compression-etc2"); const hasASTC = adapter.features.has("texture-compression-astc"); // Request device with needed features const device = await adapter.requestDevice({ requiredFeatures: hasBC ? ["texture-compression-bc"] : [], }); ``` ### Loading Compressed Data [Section titled “Loading Compressed Data”](#loading-compressed-data) Compressed textures use `writeTexture()` instead of `copyExternalImageToTexture()`: Load BC/DXT compressed texture ```javascript // Assume compressedData is Uint8Array from .dds or .ktx2 file const texture = device.createTexture({ size: [width, height], format: "bc1-rgba-unorm", // DXT1 usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST, }); device.queue.writeTexture( { texture }, compressedData, { bytesPerRow: Math.ceil(width / 4) * 8, // BC1: 8 bytes per 4x4 block rowsPerImage: Math.ceil(height / 4), }, [width, height] ); ``` ### Common Compressed Formats [Section titled “Common Compressed Formats”](#common-compressed-formats) ### Universal Texture Containers [Section titled “Universal Texture Containers”](#universal-texture-containers) **KTX2** files can contain multiple formats, transcoded at runtime: KTX2 loading pattern ```javascript // Using a KTX2 loader library import { KTX2Loader } from "ktx2-loader"; const loader = new KTX2Loader(device); const texture = await loader.load("texture.ktx2"); // Automatically transcodes to BC, ETC2, or ASTC based on device ``` ## TypeGPU Image Loading [Section titled “TypeGPU Image Loading”](#typegpu-image-loading) TypeGPU texture from image ```typescript import tgpu from "typegpu"; const root = await tgpu.init(); // Load image const response = await fetch("texture.png"); const blob = await response.blob(); const imageBitmap = await createImageBitmap(blob); // Create texture with TypeGPU const texture = root.createTexture({ size: [imageBitmap.width, imageBitmap.height], format: "rgba8unorm", }).$usage("sampled"); // Upload using raw device const device = root.unwrap().device; device.queue.copyExternalImageToTexture( { source: imageBitmap }, { texture: root.unwrap(texture) }, [imageBitmap.width, imageBitmap.height] ); ``` ## Complete Example [Section titled “Complete Example”](#complete-example) Texture loader utility ```javascript class TextureLoader { constructor(device) { this.device = device; } async fromURL(url, options = {}) { const { flipY = false, generateMipmaps = false } = options; const response = await fetch(url); const blob = await response.blob(); const imageBitmap = await createImageBitmap(blob, { colorSpaceConversion: "none", }); const { width, height } = imageBitmap; const mipLevelCount = generateMipmaps ? Math.floor(Math.log2(Math.max(width, height))) + 1 : 1; const texture = this.device.createTexture({ size: [width, height], format: "rgba8unorm", mipLevelCount, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | (generateMipmaps ? GPUTextureUsage.RENDER_ATTACHMENT : 0), }); this.device.queue.copyExternalImageToTexture( { source: imageBitmap, flipY }, { texture }, [width, height] ); if (generateMipmaps) { this.generateMipmaps(texture, mipLevelCount); } return texture; } generateMipmaps(texture, levelCount) { // See textures-samplers.md for mipmap generation } } ``` ## Resources [Section titled “Resources”](#resources)