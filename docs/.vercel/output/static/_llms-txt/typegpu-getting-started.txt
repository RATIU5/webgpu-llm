<SYSTEM>TypeGPU Getting Started: Setting up TypeGPU with bundlers and writing your first type-safe GPU program</SYSTEM>

# TypeGPU Getting Started

## Overview [Section titled “Overview”](#overview) TypeGPU is a modular toolkit for WebGPU that brings type safety and developer-friendly abstractions to GPU programming. Developed by Software Mansion, it provides advanced type inference and enables writing GPU shaders directly in TypeScript through TGSL (TypeGPU Shading Language). **Primary use cases:** * **Foundation for new projects** — Handles data serialization, buffer management, and shader composition * **Integration with existing code** — Type-safe APIs can be adopted independently * **Library interoperability** — Enables typed data sharing between WebGPU libraries ## Core Features [Section titled “Core Features”](#core-features) ### Type-Safe Data Schemas [Section titled “Type-Safe Data Schemas”](#type-safe-data-schemas) TypeGPU uses composable data schemas to manage data transfer between CPU and GPU. Every WGSL data type is represented as JavaScript schemas imported from `typegpu/data`: Defining a typed schema ```typescript import { struct, f32, vec3f, arrayOf } from "typegpu/data"; const Particle = struct({ position: vec3f, velocity: vec3f, mass: f32, }); // TypeScript type is automatically inferred type ParticleData = typeof Particle.infer; ``` Schemas provide automatic serialization/deserialization, compile-time validation, and self-documenting code. ### TGSL: TypeScript Shaders [Section titled “TGSL: TypeScript Shaders”](#tgsl-typescript-shaders) TGSL allows writing GPU shader code in TypeScript. Functions marked with `'use gpu'` are transpiled to WGSL at build time: Writing a TGSL shader ```typescript const squareNumbers = tgpu .fn([inputBuffer, outputBuffer]) .does(() => { "use gpu"; const idx = builtin.globalInvocationId.x; outputBuffer[idx] = inputBuffer[idx] * inputBuffer[idx]; }) .$name("squareNumbers"); ``` ### Bindless Resources [Section titled “Bindless Resources”](#bindless-resources) TypeGPU uses descriptive string keys instead of numeric binding indices: Named resource bindings ```typescript const resources = { particles: root.createBuffer(particleSchema).$usage("storage"), forces: root.createBuffer(forceSchema).$usage("storage"), }; ``` This improves code readability and reduces binding errors. ## Installation [Section titled “Installation”](#installation) Install TypeGPU ```bash npm install typegpu ``` Install bundler plugin for TGSL ```bash npm install --save-dev unplugin-typegpu ``` Add WebGPU type definitions ```bash npm install --save-dev @webgpu/types ``` ## Bundler Configuration [Section titled “Bundler Configuration”](#bundler-configuration) TypeGPU’s shader transpilation requires `unplugin-typegpu`. The plugin supports Vite, Webpack, Rollup, esbuild, and other bundlers via unplugin. ## First Program [Section titled “First Program”](#first-program) A complete example that squares an array of numbers on the GPU: complete-example.ts ```typescript import tgpu from "typegpu"; import { arrayOf, f32 } from "typegpu/data"; async function main() { const root = await tgpu.init(); const inputData = [1, 2, 3, 4, 5]; // Create buffers with type schemas const inputBuffer = root .createBuffer(arrayOf(f32, 5), inputData) .$usage("storage"); const outputBuffer = root .createBuffer(arrayOf(f32, 5)) .$usage("storage"); // Define compute shader const squareNumbers = tgpu .fn([inputBuffer, outputBuffer]) .does(() => { "use gpu"; const idx = builtin.globalInvocationId.x; outputBuffer[idx] = inputBuffer[idx] * inputBuffer[idx]; }) .$name("squareNumbers"); // Create and execute pipeline const pipeline = root.makeComputePipeline(squareNumbers).$workgroupSize(1); root .createCommandEncoder() .beginComputePass() .setPipeline(pipeline) .dispatchWorkgroups(5) .end() .submit(); const results = await outputBuffer.read(); console.log("Output:", Array.from(results)); // [1, 4, 9, 16, 25] root.destroy(); } main(); ``` ### Key Components [Section titled “Key Components”](#key-components) | Component | Description | | ----------------------- | ---------------------------------------------------------------------------------- | | `tgpu.init()` | Requests a GPU device and returns a root object managing all TypeGPU operations | | `arrayOf(f32, 5)` | Defines an array of 5 floats; used for buffer sizes, validation, and serialization | | `$usage("storage")` | Sets buffer usage flags (`storage`, `uniform`, `vertex`, `copy-src`, `copy-dst`) | | `"use gpu"` directive | Marks functions for TGSL transpilation | | `makeComputePipeline()` | Creates a compute pipeline from a TGSL function | | `buffer.read()` | Asynchronously retrieves data from GPU to CPU | ## Initialization Patterns [Section titled “Initialization Patterns”](#initialization-patterns) ## TypeScript Configuration [Section titled “TypeScript Configuration”](#typescript-configuration) tsconfig.json ```json { "compilerOptions": { "target": "ES2020", "module": "ESNext", "moduleResolution": "bundler", "types": ["@webgpu/types"], "strict": true } } ``` For Vite projects, add to `src/vite-env.d.ts`: src/vite-env.d.ts ```typescript /// <reference types="vite/client" /> /// <reference types="@webgpu/types" /> ``` ## Working with Schemas [Section titled “Working with Schemas”](#working-with-schemas) ### Primitive Types [Section titled “Primitive Types”](#primitive-types) Available primitives ```typescript import { f32, i32, u32, bool, vec2f, vec3f, vec4f, mat4x4f } from "typegpu/data"; ``` ### Structs [Section titled “Structs”](#structs) Defining a struct schema ```typescript import { struct, f32, vec3f } from "typegpu/data"; const Material = struct({ albedo: vec3f, roughness: f32, metallic: f32, }); ``` ### Arrays [Section titled “Arrays”](#arrays) Fixed-size arrays ```typescript import { arrayOf, f32 } from "typegpu/data"; const FloatArray = arrayOf(f32, 100); ``` ### Type Extraction [Section titled “Type Extraction”](#type-extraction) Extracting TypeScript types from schemas ```typescript const Particle = struct({ position: vec3f, velocity: vec3f, mass: f32, }); type ParticleData = typeof Particle.infer; const particle: ParticleData = { position: [0, 0, 0], velocity: [1, 0, 0], mass: 1.0, }; ``` ## Buffer Usage [Section titled “Buffer Usage”](#buffer-usage) Buffers require appropriate usage flags for different operations: Buffer usage patterns ```typescript // Storage buffer for shader read/write const storage = root.createBuffer(schema).$usage("storage"); // Uniform buffer for constants const uniform = root.createBuffer(schema).$usage("uniform"); // Buffer readable from CPU const readable = root .createBuffer(schema) .$usage("storage") .$usage("copy-src"); // Buffer writable from CPU after creation const writable = root .createBuffer(schema) .$usage("storage") .$usage("copy-dst"); ``` ## Naming Resources [Section titled “Naming Resources”](#naming-resources) Use `$name()` for debugging: Named resources for debugging ```typescript const particleBuffer = root .createBuffer(particleSchema) .$usage("storage") .$name("particlePositions"); const updateShader = tgpu .fn([particleBuffer]) .does(() => { "use gpu"; /* ... */ }) .$name("updateParticles"); ``` ## Project Structure [Section titled “Project Structure”](#project-structure) ```plaintext project-root/ ├── src/ │ ├── gpu/ │ │ ├── schemas/ # Data type definitions │ │ ├── shaders/ # TGSL functions │ │ │ ├── compute/ │ │ │ └── render/ │ │ └── pipelines/ # Pipeline configurations │ └── main.ts ├── vite.config.ts └── tsconfig.json ``` **Principles:** * Separate GPU and CPU code * Group shaders by purpose * Centralize schema definitions * Write reusable shader functions ## TGSL Requirements [Section titled “TGSL Requirements”](#tgsl-requirements) Required for TGSL TGSL functions require: 1. The `'use gpu'` directive as the first statement 2. The `unplugin-typegpu` bundler plugin configured 3. Buffer dependencies passed to `tgpu.fn()` Correct vs incorrect TGSL ```typescript // ✓ Correct const shader = tgpu.fn([buffer]).does(() => { "use gpu"; // Shader code }); // ✗ Missing directive - won't transpile const broken = tgpu.fn([buffer]).does(() => { // No 'use gpu' - this runs on CPU only }); ``` ## Resources [Section titled “Resources”](#resources)