<SYSTEM>Data Schemas in TypeGPU: Defining structs, vectors, matrices, and arrays with type inference</SYSTEM>

# Data Schemas in TypeGPU

## Overview [Section titled “Overview”](#overview) TypeGPU data schemas provide type-safe GPU data definitions with automatic serialization. Similar to how [Zod](https://zod.dev/) provides runtime type validation, TypeGPU schemas serve as both type definitions and runtime validators for GPU data structures. Schemas serve a dual purpose: 1. **Define TypeScript types** for compile-time checking 2. **Validate and serialize data** when moving between JavaScript and GPU memory ## Scalar Types [Section titled “Scalar Types”](#scalar-types) Scalar schemas represent single numeric or boolean values, mapping directly to WGSL primitives: | TypeGPU | WGSL | Description | | -------- | ------ | ----------------------- | | `d.f32` | `f32` | 32-bit float | | `d.f16` | `f16` | 16-bit float | | `d.u32` | `u32` | Unsigned 32-bit integer | | `d.i32` | `i32` | Signed 32-bit integer | | `d.bool` | `bool` | Boolean | ### Using Scalars as Constructors [Section titled “Using Scalars as Constructors”](#using-scalars-as-constructors) Creating scalar values ```typescript import * as d from "typegpu/data"; const radius = d.f32(3.14159); const particleCount = d.u32(1000); const temperature = d.i32(-40); const isActive = d.bool(true); ``` ### Scalars in Structs [Section titled “Scalars in Structs”](#scalars-in-structs) Scalar fields in structs ```typescript const Configuration = d.struct({ timeStep: d.f32, gravity: d.f32, damping: d.f32, maxParticles: d.u32, simulationEnabled: d.bool, }); ``` ## Vector Types [Section titled “Vector Types”](#vector-types) Vectors represent 2, 3, or 4 elements of the same scalar type—positions, velocities, colors. ### Constructor Patterns [Section titled “Constructor Patterns”](#constructor-patterns) Vector construction ```typescript // Zero initialization const origin = d.vec3f(); // (0.0, 0.0, 0.0) // Uniform initialization const ones = d.vec3f(1); // (1.0, 1.0, 1.0) // Component-wise const position = d.vec3f(1, 2, 3.5); const color = d.vec4f(1, 0, 0, 1); // RGBA red ``` ### Element Access [Section titled “Element Access”](#element-access) Accessing vector components ```typescript const velocity = d.vec3f(1.5, 2.0, -0.5); const x = velocity[0]; // 1.5 const y = velocity[1]; // 2.0 const z = velocity[2]; // -0.5 velocity[0] = 3.0; // Modify x ``` ### Practical Examples [Section titled “Practical Examples”](#practical-examples) Common vector use cases ```typescript const Particle = d.struct({ position: d.vec3f, velocity: d.vec3f, lifetime: d.f32, }); const ColorRGBA = d.struct({ color: d.vec4f, }); const GridCell = d.struct({ indices: d.vec3u, value: d.f32, }); ``` ## Matrix Types [Section titled “Matrix Types”](#matrix-types) Matrices handle transformations. TypeGPU supports square matrices of `f32`: | TypeGPU | WGSL | Size | | ----------- | ------------- | ---- | | `d.mat2x2f` | `mat2x2<f32>` | 2×2 | | `d.mat3x3f` | `mat3x3<f32>` | 3×3 | | `d.mat4x4f` | `mat4x4<f32>` | 4×4 | Column-Major Order Like WGSL and most graphics APIs, TypeGPU matrices use column-major order: ```typescript // Matrix stored as [column0, column1, column2] // [m00, m10, m20, m01, m11, m21, m02, m12, m22] ``` ### Integration with wgpu-matrix [Section titled “Integration with wgpu-matrix”](#integration-with-wgpu-matrix) TypeGPU works seamlessly with [wgpu-matrix](https://github.com/greggman/wgpu-matrix) via the `[]` operator: Using wgpu-matrix with TypeGPU ```typescript import { mat4, vec3 } from "wgpu-matrix"; import * as d from "typegpu/data"; const transform = d.mat4x4f(); mat4.identity(transform); const modelMatrix = d.mat4x4f(); mat4.translation([1, 2, 3], modelMatrix); mat4.rotateY(modelMatrix, Math.PI / 4, modelMatrix); const direction = d.vec3f(1, 2, 3); vec3.normalize(direction, direction); ``` ## Struct Schemas [Section titled “Struct Schemas”](#struct-schemas) Structs compose complex types from primitives and other structs, automatically handling alignment and padding. ### Basic Definition [Section titled “Basic Definition”](#basic-definition) Struct definitions ```typescript import * as d from "typegpu/data"; const Particle = d.struct({ position: d.vec3f, velocity: d.vec3f, lifetime: d.f32, }); const SimulationConfig = d.struct({ deltaTime: d.f32, gravity: d.f32, damping: d.f32, particleCount: d.u32, }); ``` ### Nested Structs [Section titled “Nested Structs”](#nested-structs) Hierarchical data structures ```typescript const Material = d.struct({ albedo: d.vec3f, metallic: d.f32, roughness: d.f32, ao: d.f32, }); const MeshInstance = d.struct({ transform: d.mat4x4f, material: Material, isVisible: d.bool, }); const SceneData = d.struct({ camera: d.struct({ viewMatrix: d.mat4x4f, projectionMatrix: d.mat4x4f, position: d.vec3f, }), ambientLight: d.vec3f, time: d.f32, }); ``` ### Automatic Alignment [Section titled “Automatic Alignment”](#automatic-alignment) vec3 Padding `vec3<f32>` requires 16-byte alignment despite being 12 bytes. TypeGPU handles this automatically: ```typescript const ExampleStruct = d.struct({ a: d.f32, // 4 bytes at offset 0 // 12 bytes padding inserted automatically b: d.vec3f, // 12 bytes at offset 16 (aligned to 16) c: d.f32, // 4 bytes at offset 28 // Padding to align struct size to 16 }); // Total: 48 bytes (not 20) ``` ### Custom Alignment [Section titled “Custom Alignment”](#custom-alignment) Override defaults when needed: Manual alignment control ```typescript const CustomAlignedStruct = d.struct({ a: d.align(16, d.f32), // Force 16-byte alignment b: d.size(32, d.vec4f), // Explicit size }); ``` ## Array Schemas [Section titled “Array Schemas”](#array-schemas) Arrays are created with `d.arrayOf()`: ### Fixed-Size Arrays [Section titled “Fixed-Size Arrays”](#fixed-size-arrays) Fixed-size arrays ```typescript const FloatArray = d.arrayOf(d.f32, 10); const ParticleArray = d.arrayOf( d.struct({ position: d.vec3f, velocity: d.vec3f, }), 100 ); const Grid = d.struct({ cells: d.arrayOf(d.f32, 64), width: d.u32, height: d.u32, }); ``` ### Runtime-Sized Arrays [Section titled “Runtime-Sized Arrays”](#runtime-sized-arrays) Runtime-sized arrays omit the length parameter: Runtime-sized arrays ```typescript const DynamicParticles = d.arrayOf( d.struct({ position: d.vec3f, velocity: d.vec3f, }) // No size - determined at runtime ); ``` Position Requirement Runtime-sized arrays must be the last field in a struct: ```typescript // ✗ Error: runtime-sized array not at end const Wrong = d.struct({ particles: d.arrayOf(d.vec3f), particleCount: d.u32, }); // ✓ Correct: runtime-sized array at end const Correct = d.struct({ particleCount: d.u32, particles: d.arrayOf(d.vec3f), }); ``` ### Nested Arrays [Section titled “Nested Arrays”](#nested-arrays) Multi-dimensional data ```typescript const HeightMap = (width: number, height: number) => d.arrayOf(d.arrayOf(d.f32, height), width); const BoneTransforms = d.struct({ bones: d.arrayOf(d.mat4x4f, 64), }); ``` ## Type Inference [Section titled “Type Inference”](#type-inference) Extract TypeScript types from schemas: Type inference ```typescript import * as d from "typegpu/data"; const Particle = d.struct({ position: d.vec3f, velocity: d.vec3f, lifetime: d.f32, }); // Infer TypeScript type type ParticleType = d.Infer<typeof Particle>; // Use in application code const particles: ParticleType[] = [ { position: [0, 0, 0], velocity: [1, 0, 0], lifetime: 1.0 }, { position: [1, 1, 1], velocity: [0, 1, 0], lifetime: 0.5 }, ]; ``` ### Schema Factory Functions [Section titled “Schema Factory Functions”](#schema-factory-functions) Dynamic schema generation ```typescript const HeightMap = (width: number, height: number) => d.arrayOf(d.arrayOf(d.f32, height), width); type HeightMapType = ReturnType<typeof HeightMap>; ``` ## Memory Layout [Section titled “Memory Layout”](#memory-layout) ### Alignment Rules [Section titled “Alignment Rules”](#alignment-rules) | Type | Size | Alignment | | ------------------- | -------- | ------------ | | `f32`, `i32`, `u32` | 4 bytes | 4 bytes | | `vec2<f32>` | 8 bytes | 8 bytes | | `vec3<f32>` | 12 bytes | **16 bytes** | | `vec4<f32>` | 16 bytes | 16 bytes | | `mat4x4<f32>` | 64 bytes | 16 bytes | TypeGPU automatically inserts padding to satisfy these requirements. ### Loose Schemas for Vertex Data [Section titled “Loose Schemas for Vertex Data”](#loose-schemas-for-vertex-data) When strict alignment isn’t required (vertex buffers), use loose schemas to save memory: Loose vs aligned schemas ```typescript // Standard struct with alignment (32 bytes) const ParticleGeometry = d.struct({ position: d.vec3f, // 16 bytes (aligned) color: d.vec4f, // 16 bytes }); // Loose struct without padding (28 bytes) const LooseParticleGeometry = d.unstruct({ position: d.vec3f, // 12 bytes (no padding) color: d.vec4f, // 16 bytes }); // Use d.disarrayOf for loose arrays const LooseVertexBuffer = d.disarrayOf(LooseParticleGeometry); ``` ## Schema Design Guidelines [Section titled “Schema Design Guidelines”](#schema-design-guidelines) ## Resources [Section titled “Resources”](#resources)