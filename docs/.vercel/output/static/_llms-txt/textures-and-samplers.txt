<SYSTEM>Textures and Samplers: Working with images, texture mapping, and sampling operations</SYSTEM>

# Textures and Samplers

## Overview [Section titled “Overview”](#overview) Textures are multi-dimensional arrays of data stored in GPU memory, optimized for spatial access patterns. Unlike buffers that store linear arrays, textures provide built-in interpolation, filtering, and addressing modes through samplers. Textures and samplers work together: * **Textures** hold pixel data in GPU memory * **Samplers** define how data is read—filtering quality, coordinate wrapping, mipmap selection ## Texture Types [Section titled “Texture Types”](#texture-types) ### 1D, 2D, 3D Textures [Section titled “1D, 2D, 3D Textures”](#1d-2d-3d-textures) ### Cube Maps [Section titled “Cube Maps”](#cube-maps) Six 2D textures arranged as cube faces for environment mapping: Cube map for skybox ```javascript const skyboxTexture = device.createTexture({ size: [512, 512, 6], // Width, height, 6 faces dimension: "2d", format: "rgba8unorm", usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST, }); const cubeView = skyboxTexture.createView({ dimension: "cube", }); ``` Sampled using 3D direction vectors rather than 2D coordinates. ### Texture Arrays [Section titled “Texture Arrays”](#texture-arrays) Multiple independent 2D images in a single texture object: Texture array for sprites ```javascript const textureArray = device.createTexture({ size: [256, 256, 10], // 10 layers of 256×256 images dimension: "2d", format: "rgba8unorm", usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST, }); const arrayView = textureArray.createView({ dimension: "2d-array", }); ``` Ideal for sprite animations and terrain splatmaps. ### Multisampled Textures [Section titled “Multisampled Textures”](#multisampled-textures) Multiple samples per pixel for antialiasing: 4× MSAA texture ```javascript const msaaTexture = device.createTexture({ size: [800, 600, 1], dimension: "2d", format: "rgba8unorm", sampleCount: 4, usage: GPUTextureUsage.RENDER_ATTACHMENT, }); ``` Caution Multisampled textures can only be render attachments. Resolve to regular textures before sampling. ## Creating Textures [Section titled “Creating Textures”](#creating-textures) ### GPUTextureDescriptor [Section titled “GPUTextureDescriptor”](#gputexturedescriptor) Complete texture creation ```javascript const texture = device.createTexture({ label: "Main Color Texture", size: { width: 512, height: 512, depthOrArrayLayers: 1 }, dimension: "2d", format: "rgba8unorm", usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT, mipLevelCount: 1, sampleCount: 1, }); ``` | Property | Description | | --------------- | -------------------------------------------------- | | `label` | Debug string for error messages | | `size` | Dimensions as object or `[width, height?, depth?]` | | `dimension` | `'1d'`, `'2d'`, or `'3d'` | | `format` | Pixel format (see formats section) | | `usage` | Bitwise combination of usage flags | | `mipLevelCount` | Number of mipmap levels | | `sampleCount` | 1 (default) or 4 (MSAA) | ### Usage Flags [Section titled “Usage Flags”](#usage-flags) | Flag | Purpose | | ----------------------- | -------------------------- | | `TEXTURE_BINDING` | Sample in shaders | | `STORAGE_BINDING` | Read-write storage texture | | `RENDER_ATTACHMENT` | Render target | | `COPY_SRC` / `COPY_DST` | Copy operations | ### Mipmap Levels [Section titled “Mipmap Levels”](#mipmap-levels) For a full mipmap chain: Calculate mip levels ```javascript const maxDimension = Math.max(width, height); const mipLevelCount = Math.floor(Math.log2(maxDimension)) + 1; // 512×512 → 10 levels: 512→256→128→64→32→16→8→4→2→1 ``` ## Common Texture Formats [Section titled “Common Texture Formats”](#common-texture-formats) | Format | Description | Use Case | | -------------- | ---------------------- | ---------------------------- | | `rgba8unorm` | 8-bit RGBA, normalized | Standard color | | `bgra8unorm` | 8-bit BGRA, normalized | Canvas render targets | | `depth24plus` | ≥24-bit depth | Depth buffers | | `depth32float` | 32-bit float depth | Shader-accessible depth | | `r32float` | Single-channel float | Height maps, distance fields | | `rgba16float` | 16-bit float RGBA | HDR rendering | | `r8unorm` | Single-channel 8-bit | Masks, grayscale | Get preferred canvas format ```javascript const preferredFormat = navigator.gpu.getPreferredCanvasFormat(); // 'bgra8unorm' on macOS/Metal, 'rgba8unorm' on Windows/D3D12 ``` Format Compatibility Not all formats work with all usages. `r32float` cannot be a `RENDER_ATTACHMENT` without checking device features. ## Loading Images [Section titled “Loading Images”](#loading-images) ### From URL [Section titled “From URL”](#from-url) Load texture from image file ```javascript async function loadTexture(device, url) { const response = await fetch(url); const blob = await response.blob(); const imageBitmap = await createImageBitmap(blob); const texture = device.createTexture({ size: [imageBitmap.width, imageBitmap.height, 1], format: "rgba8unorm", usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT, }); device.queue.copyExternalImageToTexture( { source: imageBitmap }, { texture: texture }, [imageBitmap.width, imageBitmap.height] ); return texture; } ``` ### From Canvas [Section titled “From Canvas”](#from-canvas) Procedural texture from canvas ```javascript function createProceduralTexture(device, size) { const canvas = document.createElement("canvas"); canvas.width = size; canvas.height = size; const ctx = canvas.getContext("2d"); const gradient = ctx.createLinearGradient(0, 0, size, size); gradient.addColorStop(0, "#ff0000"); gradient.addColorStop(1, "#0000ff"); ctx.fillStyle = gradient; ctx.fillRect(0, 0, size, size); const texture = device.createTexture({ size: [size, size], format: "rgba8unorm", usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST, }); device.queue.copyExternalImageToTexture( { source: canvas }, { texture: texture }, [size, size] ); return texture; } ``` ### copyExternalImageToTexture Sources [Section titled “copyExternalImageToTexture Sources”](#copyexternalimagetotexture-sources) * `ImageBitmap` * `HTMLCanvasElement` * `OffscreenCanvas` * `HTMLVideoElement` Flip image on upload ```javascript device.queue.copyExternalImageToTexture( { source: imageBitmap, flipY: true }, { texture: texture }, [width, height] ); ``` ## Samplers [Section titled “Samplers”](#samplers) ### Creating Samplers [Section titled “Creating Samplers”](#creating-samplers) Complete sampler configuration ```javascript const sampler = device.createSampler({ label: "Linear Repeat Sampler", addressModeU: "repeat", addressModeV: "repeat", addressModeW: "repeat", magFilter: "linear", minFilter: "linear", mipmapFilter: "linear", maxAnisotropy: 1, lodMinClamp: 0, lodMaxClamp: 10, }); ``` ### Filtering Modes [Section titled “Filtering Modes”](#filtering-modes) | Property | `'nearest'` | `'linear'` | | -------------- | ------------------------------ | -------------------- | | `magFilter` | Pixelated (good for pixel art) | Smooth interpolation | | `minFilter` | May cause flickering | Reduces aliasing | | `mipmapFilter` | Abrupt mip transitions | Smooth mip blending | Common sampler presets ```javascript // Pixel art / retro const pixelSampler = device.createSampler({ magFilter: "nearest", minFilter: "nearest", }); // Smooth texturing const linearSampler = device.createSampler({ magFilter: "linear", minFilter: "linear", mipmapFilter: "linear", }); // High quality with anisotropic filtering const qualitySampler = device.createSampler({ magFilter: "linear", minFilter: "linear", mipmapFilter: "linear", maxAnisotropy: 16, }); ``` ### Address Modes [Section titled “Address Modes”](#address-modes) | Mode | Behavior | | ----------------- | ------------------------------ | | `'clamp-to-edge'` | Edge texel repeated infinitely | | `'repeat'` | Texture tiles (1.5 → 0.5) | | `'mirror-repeat'` | Alternates direction at edges | Address mode examples ```javascript // Tiling textures (brick walls, terrain) const tiledSampler = device.createSampler({ addressModeU: "repeat", addressModeV: "repeat", magFilter: "linear", minFilter: "linear", }); // UI elements, skyboxes (no repeat) const clampedSampler = device.createSampler({ addressModeU: "clamp-to-edge", addressModeV: "clamp-to-edge", magFilter: "linear", minFilter: "linear", }); ``` ### Anisotropic Filtering [Section titled “Anisotropic Filtering”](#anisotropic-filtering) Improves quality for surfaces viewed at oblique angles: Enable anisotropic filtering ```javascript const sampler = device.createSampler({ magFilter: "linear", minFilter: "linear", mipmapFilter: "linear", maxAnisotropy: 16, // 1, 2, 4, 8, or 16 }); ``` ## Mipmapping [Section titled “Mipmapping”](#mipmapping) Mipmaps are pre-computed, progressively smaller texture versions: ```plaintext Level 0: 512×512 (original) Level 1: 256×256 Level 2: 128×128 ... Level 9: 1×1 ``` ### Manual Mipmap Data [Section titled “Manual Mipmap Data”](#manual-mipmap-data) Create texture with mipmaps ```javascript const mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1; const texture = device.createTexture({ size: [width, height], format: "rgba8unorm", mipLevelCount: mipLevelCount, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST, }); // Write each mip level for (let mipLevel = 0; mipLevel < mipLevelCount; mipLevel++) { const mipWidth = Math.max(1, width >> mipLevel); const mipHeight = Math.max(1, height >> mipLevel); const mipData = generateMipData(mipLevel); device.queue.writeTexture( { texture: texture, mipLevel: mipLevel }, mipData, { bytesPerRow: mipWidth * 4 }, [mipWidth, mipHeight] ); } ``` Caution WebGPU doesn’t provide built-in mipmap generation. Use compute shaders or render passes to downsample. ### Generating Mipmaps [Section titled “Generating Mipmaps”](#generating-mipmaps) Unlike WebGL’s `generateMipmap()`, WebGPU requires manual mipmap generation. ## Sampling in Shaders [Section titled “Sampling in Shaders”](#sampling-in-shaders) ### textureSample [Section titled “textureSample”](#texturesample) Filtered texture lookup (uses sampler settings): Basic texture sampling ```wgsl @group(0) @binding(0) var textureSampler: sampler; @group(0) @binding(1) var colorTexture: texture_2d<f32>; @fragment fn fragmentMain(@location(0) texCoord: vec2f) -> @location(0) vec4f { let color = textureSample(colorTexture, textureSampler, texCoord); return color; } ``` ### textureLoad [Section titled “textureLoad”](#textureload) Direct texel access without filtering: Load exact texel value ```wgsl @group(0) @binding(0) var inputTexture: texture_2d<f32>; @fragment fn fragmentMain(@location(0) texCoord: vec2f) -> @location(0) vec4f { let dimensions = textureDimensions(inputTexture); let pixelCoord = vec2<i32>(texCoord * vec2f(dimensions)); let color = textureLoad(inputTexture, pixelCoord, 0); return color; } ``` ### Complete Shader Example [Section titled “Complete Shader Example”](#complete-shader-example) Full texture sampling shader ```wgsl struct VertexOutput { @builtin(position) position: vec4f, @location(0) texCoord: vec2f, }; @vertex fn vertexMain( @location(0) position: vec3f, @location(1) texCoord: vec2f ) -> VertexOutput { var output: VertexOutput; output.position = vec4f(position, 1.0); output.texCoord = texCoord; return output; } @group(0) @binding(0) var textureSampler: sampler; @group(0) @binding(1) var diffuseTexture: texture_2d<f32>; @fragment fn fragmentMain(input: VertexOutput) -> @location(0) vec4f { return textureSample(diffuseTexture, textureSampler, input.texCoord); } ``` ## TypeGPU Texture Support [Section titled “TypeGPU Texture Support”](#typegpu-texture-support) TypeGPU texture binding ```typescript import tgpu from "typegpu"; // Define texture and sampler slots const diffuseTextureSlot = tgpu.textureSlot({ format: "rgba8unorm", dimension: "2d", }); const samplerSlot = tgpu.samplerSlot(); // Create shader using slots const fragmentShader = tgpu.fragmentFn((texCoord: vec2f) => { const color = diffuseTextureSlot.sample(samplerSlot, texCoord); return { color }; }); ``` ## Texture Coordinates [Section titled “Texture Coordinates”](#texture-coordinates) ### UV Space [Section titled “UV Space”](#uv-space) Coordinates range from 0 to 1: ```plaintext (0,0) ────────────> U │ Top-left origin │ (WebGPU convention) v V (1,1) ``` Origin Conventions WebGPU uses top-left origin. Some image formats use bottom-left. Use `flipY: true` when loading if needed. Vertex data with UVs ```javascript const vertices = new Float32Array([ // Position (x,y,z) TexCoord (u,v) -1.0, -1.0, 0.0, 0.0, 1.0, // Bottom-left 1.0, -1.0, 0.0, 1.0, 1.0, // Bottom-right 1.0, 1.0, 0.0, 1.0, 0.0, // Top-right -1.0, 1.0, 0.0, 0.0, 0.0, // Top-left ]); ``` ### Texture Atlases [Section titled “Texture Atlases”](#texture-atlases) Combine multiple small textures to reduce bind group changes: Texture atlas approach ```javascript const atlas = device.createTexture({ size: [2048, 2048], format: "rgba8unorm", usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST, }); // Calculate UVs for specific sprite region function getSpriteUVs(spriteIndex, atlasLayout) { const col = spriteIndex % atlasLayout.columns; const row = Math.floor(spriteIndex / atlasLayout.columns); const u = col / atlasLayout.columns; const v = row / atlasLayout.rows; const spriteWidth = 1 / atlasLayout.columns; const spriteHeight = 1 / atlasLayout.rows; return { u, v, width: spriteWidth, height: spriteHeight }; } ``` ## Depth Textures [Section titled “Depth Textures”](#depth-textures) ### Depth Formats [Section titled “Depth Formats”](#depth-formats) | Format | Bits | Shader Access | Use Case | | ----------------------- | ---- | ------------- | ----------------------- | | `depth24plus` | ≥24 | No | Standard depth buffer | | `depth32float` | 32 | Yes | Shadow mapping, effects | | `depth24plus-stencil8` | 24+8 | No | Depth + stencil | | `depth32float-stencil8` | 32+8 | Depth only | Depth access + stencil | ### Creating Depth Textures [Section titled “Creating Depth Textures”](#creating-depth-textures) Shader-accessible depth texture ```javascript const depthTexture = device.createTexture({ size: [canvas.width, canvas.height], format: "depth32float", usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING, }); ``` ### Shadow Mapping [Section titled “Shadow Mapping”](#shadow-mapping) ### Reading Depth Without Comparison [Section titled “Reading Depth Without Comparison”](#reading-depth-without-comparison) For post-processing effects that need raw depth values: Read raw depth values ```wgsl @group(0) @binding(0) var depthTex: texture_depth_2d; @fragment fn main(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f { let depth = textureLoad(depthTex, vec2i(fragCoord.xy), 0); // depth is in [0, 1] range (0 = near, 1 = far) return vec4f(depth, depth, depth, 1.0); } ``` ## Resource Cleanup [Section titled “Resource Cleanup”](#resource-cleanup) Memory Management Large textures consume significant GPU memory. Destroy when no longer needed: ```javascript texture.destroy(); // Free GPU memory immediately ``` ## Resources [Section titled “Resources”](#resources)