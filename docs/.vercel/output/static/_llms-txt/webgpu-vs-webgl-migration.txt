<SYSTEM>WebGPU vs WebGL Migration: Differences, advantages, and migration considerations including coordinate system changes</SYSTEM>

# WebGPU vs WebGL Migration Guide

## Overview [Section titled “Overview”](#overview) WebGPU represents a fundamental shift from WebGL’s OpenGL-based design toward a modern, low-level graphics API inspired by Vulkan, Metal, and Direct3D 12. It offers explicit control over GPU resources, better performance through reduced CPU overhead, and compute shader support. ## Architectural Differences [Section titled “Architectural Differences”](#architectural-differences) ### State Management [Section titled “State Management”](#state-management) **WebGL** uses a global state machine where settings persist until changed: WebGL global state ```javascript gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.enableVertexAttribArray(0); // State remains for all subsequent draws ``` **WebGPU** uses immutable pipeline objects created upfront: WebGPU stateless pipeline ```javascript const pipeline = device.createRenderPipeline({ layout: "auto", vertex: { module: shaderModule, entryPoint: "vertexMain", buffers: [...] }, fragment: { module: shaderModule, entryPoint: "fragmentMain", targets: [...] }, primitive: { topology: "triangle-list" }, }); // Switch pipelines explicitly pass.setPipeline(pipeline); ``` ### Command Model [Section titled “Command Model”](#command-model) **WebGL** executes commands immediately: ```javascript gl.drawArrays(gl.TRIANGLES, 0, 3); // Executes immediately ``` **WebGPU** records commands into buffers, then submits: WebGPU command buffer pattern ```javascript const encoder = device.createCommandEncoder(); const pass = encoder.beginRenderPass(descriptor); pass.setPipeline(pipeline); pass.setVertexBuffer(0, vertexBuffer); pass.draw(3); pass.end(); device.queue.submit([encoder.finish()]); // Actual execution ``` ## Shading Languages [Section titled “Shading Languages”](#shading-languages) ### GLSL to WGSL [Section titled “GLSL to WGSL”](#glsl-to-wgsl) WebGL GLSL ```glsl attribute vec3 position; uniform mat4 modelViewProjection; varying vec2 vTexCoord; void main() { gl_Position = modelViewProjection * vec4(position, 1.0); } ``` WebGPU WGSL ```wgsl struct VertexOutput { @builtin(position) position: vec4<f32>, @location(0) texCoord: vec2<f32>, } @group(0) @binding(0) var<uniform> mvp: mat4x4<f32>; @vertex fn vertexMain(@location(0) position: vec3<f32>) -> VertexOutput { var output: VertexOutput; output.position = mvp * vec4<f32>(position, 1.0); return output; } ``` ### Key Translation Points [Section titled “Key Translation Points”](#key-translation-points) | GLSL | WGSL | | ------------------- | ----------------------------------------- | | `attribute` | `@location(n)` input | | `varying` | `@location(n)` output | | `uniform sampler2D` | `texture_2d` + `sampler` | | `texture2D()` | `textureSample()` | | `gl_Position` | `@builtin(position)` | | `gl_FragColor` | Return with `@location(0)` | | `vec4` | `vec4<f32>` | | `main()` | Named function with `@vertex`/`@fragment` | ## Coordinate System Changes [Section titled “Coordinate System Changes”](#coordinate-system-changes) ### Depth Range [Section titled “Depth Range”](#depth-range) Critical Migration Issue WebGPU uses 0 to 1 depth range (not -1 to 1). Using WebGL projection matrices causes incorrect clipping. WebGPU perspective matrix (0-1 depth) ```javascript function perspectiveZO(fov, aspect, near, far) { const f = 1.0 / Math.tan(fov / 2); const rangeInv = 1.0 / (near - far); return [ f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, far * rangeInv, -1, 0, 0, near * far * rangeInv, 0, ]; } ``` ### Framebuffer Origin [Section titled “Framebuffer Origin”](#framebuffer-origin) | Aspect | WebGL | WebGPU | | ----------- | ----------- | -------- | | Origin | Bottom-left | Top-left | | Y Direction | Up | Down | **Texture coordinate fix:** Flip Y in shader ```wgsl let flippedUV = vec2<f32>(texCoord.x, 1.0 - texCoord.y); let color = textureSample(tex, samp, flippedUV); ``` ## Compute Shaders [Section titled “Compute Shaders”](#compute-shaders) WebGPU’s major feature addition over WebGL: WebGPU compute shader ```wgsl @group(0) @binding(0) var<storage, read> input: array<f32>; @group(0) @binding(1) var<storage, read_write> output: array<f32>; @compute @workgroup_size(64) fn main(@builtin(global_invocation_id) id: vec3<u32>) { if (id.x < arrayLength(&input)) { output[id.x] = input[id.x] * 2.0; } } ``` ## Common Migration Issues [Section titled “Common Migration Issues”](#common-migration-issues) ## Side-by-Side Comparison [Section titled “Side-by-Side Comparison”](#side-by-side-comparison) ### WebGL Triangle [Section titled “WebGL Triangle”](#webgl-triangle) WebGL triangle ```javascript const gl = canvas.getContext("webgl"); // Compile shaders const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vertexSource); gl.compileShader(vs); const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, fragmentSource); gl.compileShader(fs); // Link program const program = gl.createProgram(); gl.attachShader(program, vs); gl.attachShader(program, fs); gl.linkProgram(program); gl.useProgram(program); // Create buffer const buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); // Configure attributes const loc = gl.getAttribLocation(program, "position"); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0); // Draw gl.drawArrays(gl.TRIANGLES, 0, 3); ``` ### WebGPU Triangle [Section titled “WebGPU Triangle”](#webgpu-triangle) WebGPU triangle ```javascript const adapter = await navigator.gpu.requestAdapter(); const device = await adapter.requestDevice(); const context = canvas.getContext("webgpu"); context.configure({ device, format: navigator.gpu.getPreferredCanvasFormat() }); const pipeline = device.createRenderPipeline({ layout: "auto", vertex: { module: device.createShaderModule({ code: shaderCode }), entryPoint: "vertexMain", buffers: [{ arrayStride: 8, attributes: [{ shaderLocation: 0, offset: 0, format: "float32x2" }], }], }, fragment: { module: device.createShaderModule({ code: shaderCode }), entryPoint: "fragmentMain", targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }], }, }); const vertexBuffer = device.createBuffer({ size: vertices.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, }); device.queue.writeBuffer(vertexBuffer, 0, vertices); const encoder = device.createCommandEncoder(); const pass = encoder.beginRenderPass({ colorAttachments: [{ view: context.getCurrentTexture().createView(), loadOp: "clear", storeOp: "store", }], }); pass.setPipeline(pipeline); pass.setVertexBuffer(0, vertexBuffer); pass.draw(3); pass.end(); device.queue.submit([encoder.finish()]); ``` ## When to Migrate [Section titled “When to Migrate”](#when-to-migrate) ### Good Candidates [Section titled “Good Candidates”](#good-candidates) | Scenario | Reason | | ----------------------------- | ---------------------------------- | | Compute-heavy applications | GPGPU not possible in WebGL | | Performance-critical projects | Reduced CPU overhead | | New projects | Better architecture, future-proof | | Complex rendering | Explicit control, fewer state bugs | ### Stay with WebGL [Section titled “Stay with WebGL”](#stay-with-webgl) | Scenario | Reason | | ----------------------------- | ------------------------------------ | | Maximum browser compatibility | WebGL works on older devices | | Simple 2D graphics | WebGL is simpler for basic use | | Stable existing codebases | Migration cost may outweigh benefits | | Limited development resources | WebGPU has steeper learning curve | ## Migration Strategies [Section titled “Migration Strategies”](#migration-strategies) ### Gradual Migration [Section titled “Gradual Migration”](#gradual-migration) Feature detection with fallback ```javascript if (navigator.gpu) { const adapter = await navigator.gpu.requestAdapter(); if (adapter) { return initWebGPURenderer(await adapter.requestDevice()); } } return initWebGLRenderer(); ``` ### Feature-by-Feature [Section titled “Feature-by-Feature”](#feature-by-feature) 1. Start with compute shaders (new functionality) 2. Move particle systems (performance benefit) 3. Convert main rendering pipeline (largest impact) 4. Migrate post-processing effects 5. Update UI rendering last Alignment Requirements WebGPU has strict buffer alignment (typically 256 bytes for uniforms). Calculate sizes carefully: ```javascript const alignedSize = Math.ceil(dataSize / 256) * 256; ``` ## Resources [Section titled “Resources”](#resources)